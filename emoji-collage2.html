<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emoji Collage Maker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/preact/10.25.4/preact.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/preact/10.25.4/hooks.umd.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .emoji-grid {
      display: block;
      font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji";
      line-height: 1em;
      letter-spacing: -0.4em;
      -webkit-text-size-adjust: none;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #ccc;
      transition: background-color 0.3s;
      margin-left: 8px;
    }

    .collage-container {
      overflow: visible;
      position: relative;
      margin-top: 1rem;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .zoom-button {
      padding: 4px 8px;
      background-color: #e2e8f0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .zoom-button:hover {
      background-color: #cbd5e1;
    }

    #processingCanvas {
      display: block;
      margin-top: 1rem;
      border: 1px solid #ccc;
      max-width: 100%;
    }
  </style>
</head>

<body class="bg-gray-100">
  <div id="app"></div>

  <script>
    const { h, render } = window.preact;
    const { useState, useEffect, useRef } = window.preactHooks;

    // Helper: Convert hex (e.g. "#ffffff") to an RGB array.
    const hexToRgb = (hex) => {
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const num = parseInt(hex, 16);
      return [(num >> 16) & 255, (num >> 8) & 255, num & 255];
    };

    // LAB conversion functions for perceptual matching.
    function rgbToXyz(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x, y, z];
    }

    function xyzToLab(x, y, z) {
      const refX = 0.95047, refY = 1.000, refZ = 1.08883;
      x /= refX; y /= refY; z /= refZ;
      x = x > 0.008856 ? Math.cbrt(x) : (7.787 * x) + (16 / 116);
      y = y > 0.008856 ? Math.cbrt(y) : (7.787 * y) + (16 / 116);
      z = z > 0.008856 ? Math.cbrt(z) : (7.787 * z) + (16 / 116);
      const L = (116 * y) - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [L, a, b];
    }

    function rgbToLab(r, g, b) {
      return xyzToLab(...rgbToXyz(r, g, b));
    }

    /*  
      Extract the representative color for an emoji.
      We create a 50Ã—50 canvas with a white background, draw the emoji at 40px,
      then average the colors of fully opaque (non-white) pixels.
    */
    const extractEmojiColor = (emoji) => {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        canvas.width = 50;
        canvas.height = 50;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = '#FF00FF'; // Hot pink - very uncommon in emojis
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = '40px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(emoji, canvas.width / 2, canvas.height / 2);
        // Slight delay to ensure rendering.
        setTimeout(() => {
          try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < data.length; i += 4) {
              // Only count pixels that are fully opaque and not nearly hot-pink.
              if (data[i + 3] > 250 && !(data[i] > 250 && data[i + 1] < 5 && data[i + 2] > 250)) {
                r += data[i];
                g += data[i + 1];
                b += data[i + 2];
                count++;
              }
            }
            if (count > 0) {
              resolve([Math.round(r / count), Math.round(g / count), Math.round(b / count)]);
            } else {
              resolve([128, 128, 128]);
            }
          } catch (error) {
            console.error('Error analyzing emoji:', error);
            resolve([128, 128, 128]);
          }
        }, 10);
      });
    };


    /* Debug logging helper */
    const debug = {
      error: (msg, err) => {
        console.error(`[Emoji Collage] ${msg}`, err);
        return false;
      },
      log: (msg, ...args) => console.log(`[Emoji Collage] ${msg}`, ...args)
    };


    /* 
      Measure emoji width consistency.
      Returns true if the emoji renders at the expected width.
    */
    const checkEmojiWidth = (emoji) => {
      try {
        const canvas = document.createElement('canvas');
        if (!canvas) {
          return debug.error('Failed to create canvas');
        }

        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) {
          return debug.error('Failed to get canvas context');
        }

        ctx.font = '40px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"';
        const metrics = ctx.measureText(emoji);
        const expectedWidth = 54.921875;
        const actualWidth = metrics.width;

        debug.log(`Emoji ${emoji} width: ${actualWidth}px`);

        return Math.abs(actualWidth - expectedWidth) <= (expectedWidth * 0.05);
      } catch (err) {
        return debug.error(`Error measuring emoji ${emoji}:`, err);
      }
    };


    const EMOJI_CATEGORIES = {
      ALL: {
        name: 'All Emojis'
      },
      FACES_AND_PEOPLE: {
        name: 'Faces & People',
        /* No skin tone variations */
        base: 'ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜…ðŸ˜‚ðŸ¤£â˜ºï¸ðŸ˜ŠðŸ˜‡ðŸ™‚ðŸ™ƒðŸ˜‰ðŸ˜ŒðŸ˜ðŸ¥°ðŸ˜˜ðŸ˜—ðŸ˜™ðŸ˜šðŸ˜‹ðŸ˜›ðŸ˜ðŸ˜œðŸ¤ªðŸ¤¨ðŸ§ðŸ¤“ðŸ˜ŽðŸ¥¸ðŸ¤©ðŸ¥³ðŸ˜ðŸ˜’ðŸ˜žðŸ˜”ðŸ˜ŸðŸ˜•ðŸ™â˜¹ï¸ðŸ˜£ðŸ˜–ðŸ˜«ðŸ˜©ðŸ¥ºðŸ˜¢ðŸ˜­ðŸ˜¤ðŸ˜ ðŸ˜¡ðŸ¤¬ðŸ¤¯ðŸ˜³ðŸ¥µðŸ¥¶ðŸ˜±ðŸ˜¨ðŸ˜°ðŸ˜¥ðŸ˜“ðŸ«£ðŸ¤—ðŸ«¡ðŸ¤”ðŸ«¢ðŸ¤­ðŸ¤«ðŸ¤¥ðŸ˜¶ðŸ˜¶â€ðŸŒ«ï¸ðŸ˜ðŸ˜‘ðŸ˜¬ðŸ«¨ðŸ« ðŸ™„ðŸ˜¯ðŸ˜¦ðŸ˜§ðŸ˜®ðŸ˜²ðŸ¥±ðŸ˜´ðŸ¤¤ðŸ˜ªðŸ˜µðŸ˜µâ€ðŸ’«ðŸ«¥ðŸ¤ðŸ¥´ðŸ¤¢ðŸ¤®ðŸ¤§ðŸ˜·ðŸ¤’ðŸ¤•ðŸ¤‘ðŸ¤ ðŸ˜ˆðŸ‘¿ðŸ‘¹ðŸ‘ºðŸ¤¡ðŸ’©ðŸ‘»ðŸ’€â˜ ï¸ðŸ‘½ðŸ‘¾ðŸ¤–ðŸŽƒðŸ˜ºðŸ˜¸ðŸ˜¹ðŸ˜»ðŸ˜¼ðŸ˜½ðŸ™€ðŸ˜¿ðŸ˜¾',
        /* Support skin tone variations */
        toneSupport: 'ðŸ‘¶ðŸ‘§ðŸ§’ðŸ‘¦ðŸ‘©ðŸ§‘ðŸ‘¨ðŸ‘©â€ðŸ¦±ðŸ§‘â€ðŸ¦±ðŸ‘¨â€ðŸ¦±ðŸ‘©â€ðŸ¦°ðŸ§‘â€ðŸ¦°ðŸ‘¨â€ðŸ¦°ðŸ‘±â€â™€ï¸ðŸ‘±ðŸ‘±â€â™‚ï¸ðŸ‘©â€ðŸ¦³ðŸ§‘â€ðŸ¦³ðŸ‘¨â€ðŸ¦³ðŸ‘©â€ðŸ¦²ðŸ§‘â€ðŸ¦²ðŸ‘¨â€ðŸ¦²ðŸ§”â€â™€ï¸ðŸ§”ðŸ§”â€â™‚ï¸ðŸ‘µðŸ§“ðŸ‘´ðŸ‘²ðŸ‘³â€â™€ï¸ðŸ‘³ðŸ‘³â€â™‚ï¸ðŸ§•ðŸ‘®â€â™€ï¸ðŸ‘®ðŸ‘®â€â™‚ï¸ðŸ‘·â€â™€ï¸ðŸ‘·ðŸ‘·â€â™‚ï¸ðŸ’‚â€â™€ï¸ðŸ’‚ðŸ’‚â€â™‚ï¸ðŸ•µï¸â€â™€ï¸ðŸ•µï¸ðŸ•µï¸â€â™‚ï¸ðŸ‘©â€âš•ï¸ðŸ§‘â€âš•ï¸ðŸ‘¨â€âš•ï¸ðŸ‘©â€ðŸŒ¾ðŸ§‘â€ðŸŒ¾ðŸ‘¨â€ðŸŒ¾ðŸ‘©â€ðŸ³ðŸ§‘â€ðŸ³ðŸ‘¨â€ðŸ³ðŸ‘©â€ðŸŽ“ðŸ§‘â€ðŸŽ“ðŸ‘¨â€ðŸŽ“ðŸ‘©â€ðŸŽ¤ðŸ§‘â€ðŸŽ¤ðŸ‘¨â€ðŸŽ¤ðŸ‘©â€ðŸ«ðŸ§‘â€ðŸ«ðŸ‘¨â€ðŸ«ðŸ‘©â€ðŸ­ðŸ§‘â€ðŸ­ðŸ‘¨â€ðŸ­ðŸ‘©â€ðŸ’»ðŸ§‘â€ðŸ’»ðŸ‘¨â€ðŸ’»ðŸ‘©â€ðŸ’¼ðŸ§‘â€ðŸ’¼ðŸ‘¨â€ðŸ’¼ðŸ‘©â€ðŸ”§ðŸ§‘â€ðŸ”§ðŸ‘¨â€ðŸ”§ðŸ‘©â€ðŸ”¬ðŸ§‘â€ðŸ”¬ðŸ‘¨â€ðŸ”¬ðŸ‘©â€ðŸŽ¨ðŸ§‘â€ðŸŽ¨ðŸ‘¨â€ðŸŽ¨ðŸ‘©â€ðŸš’ðŸ§‘â€ðŸš’ðŸ‘¨â€ðŸš’ðŸ‘©â€âœˆï¸ðŸ§‘â€âœˆï¸ðŸ‘¨â€âœˆï¸ðŸ‘©â€ðŸš€ðŸ§‘â€ðŸš€ðŸ‘¨â€ðŸš€ðŸ‘©â€âš–ï¸ðŸ§‘â€âš–ï¸ðŸ‘¨â€âš–ï¸ðŸ‘°â€â™€ï¸ðŸ‘°ðŸ‘°â€â™‚ï¸ðŸ¤µâ€â™€ï¸ðŸ¤µðŸ¤µâ€â™‚ï¸ðŸ‘¸ðŸ«…ðŸ¤´ðŸ™‡â€â™€ï¸ðŸ™‡ðŸ™‡â€â™‚ï¸ðŸ’â€â™€ï¸ðŸ’ðŸ’â€â™‚ï¸ðŸ™…â€â™€ï¸ðŸ™…ðŸ™…â€â™‚ï¸ðŸ™†â€â™€ï¸ðŸ™†ðŸ™†â€â™‚ï¸ðŸ™‹â€â™€ï¸ðŸ™‹ðŸ™‹â€â™‚ï¸ðŸ§â€â™€ï¸ðŸ§ðŸ§â€â™‚ï¸ðŸ¤¦â€â™€ï¸ðŸ¤¦ðŸ¤¦â€â™‚ï¸ðŸ¤·â€â™€ï¸ðŸ¤·ðŸ¤·â€â™‚ï¸ðŸ™Žâ€â™€ï¸ðŸ™ŽðŸ™Žâ€â™‚ï¸ðŸ™â€â™€ï¸ðŸ™ðŸ™â€â™‚ï¸ðŸ’‡â€â™€ï¸ðŸ’‡ðŸ’‡â€â™‚ï¸ðŸ’†â€â™€ï¸ðŸ’†ðŸ’†â€â™‚ï¸ðŸ§–â€â™€ï¸ðŸ§–ðŸ§–â€â™‚ï¸ðŸ’…ðŸ¤³ðŸ’ƒðŸ•ºðŸ‘¯â€â™€ï¸ðŸ‘¯ðŸ‘¯â€â™‚ï¸ðŸ•´ðŸ‘©â€ðŸ¦½ðŸ§‘â€ðŸ¦½ðŸ‘¨â€ðŸ¦½ðŸ‘©â€ðŸ¦¼ðŸ§‘â€ðŸ¦¼ðŸ‘¨â€ðŸ¦¼ðŸš¶â€â™€ï¸ðŸš¶ðŸš¶â€â™‚ï¸ðŸ‘©â€ðŸ¦¯ðŸ§‘â€ðŸ¦¯ðŸ‘¨â€ðŸ¦¯ðŸ§Žâ€â™€ï¸ðŸ§ŽðŸ§Žâ€â™‚ï¸ðŸƒâ€â™€ï¸ðŸƒðŸƒâ€â™‚ï¸ðŸ§â€â™€ï¸ðŸ§ðŸ§â€â™‚ï¸ðŸ¤²ðŸ‘ðŸ™ŒðŸ‘ðŸ¤ðŸ‘ðŸ‘ŽðŸ‘ŠâœŠðŸ¤›ðŸ¤œðŸ¤žâœŒï¸ðŸ¤ŸðŸ¤˜ðŸ‘ŒðŸ¤ŒðŸ¤ðŸ‘ˆðŸ‘‰ðŸ‘†ðŸ‘‡â˜ï¸âœ‹ðŸ¤šðŸ–ï¸ðŸ––ðŸ‘‹ðŸ¤™ðŸ’ªðŸ¦¾âœï¸ðŸ™ðŸ¦¶ðŸ¦µ'
      },
      NATURE: {
        name: 'Nature',
        animals: 'ðŸ¶ðŸ±ðŸ­ðŸ¹ðŸ°ðŸ¦ŠðŸ»ðŸ¼ðŸ»â€â„ï¸ðŸ¨ðŸ¯ðŸ¦ðŸ®ðŸ·ðŸ½ðŸ¸ðŸµðŸ™ˆðŸ™‰ðŸ™ŠðŸ’ðŸ”ðŸ§ðŸ¦ðŸ¤ðŸ£ðŸ¥ðŸ¦†ðŸ¦…ðŸ¦‰ðŸ¦‡ðŸºðŸ—ðŸ´ðŸ¦„ðŸðŸª±ðŸ›ðŸ¦‹ðŸŒðŸžðŸœðŸª°ðŸª²ðŸª³ðŸ¦ŸðŸ¦—ðŸ•·ðŸ•¸ðŸ¦‚ðŸ¢ðŸðŸ¦ŽðŸ¦–ðŸ¦•ðŸ™ðŸ¦‘ðŸ¦ðŸ¦žðŸ¦€ðŸ¡ðŸ ðŸŸðŸ¬ðŸ³ðŸ‹ðŸ¦ˆðŸŠðŸ…ðŸ†ðŸ¦“ðŸ¦ðŸ¦§ðŸ¦£ðŸ˜ðŸ¦›ðŸ¦ðŸªðŸ«ðŸ¦’ðŸ¦˜ðŸ¦¬ðŸƒðŸ‚ðŸ„ðŸŽðŸ–ðŸðŸ‘ðŸ¦™ðŸðŸ¦ŒðŸ•ðŸ©ðŸ¦®ðŸ•â€ðŸ¦ºðŸˆðŸˆâ€â¬›ðŸª¶ðŸ“ðŸ¦ƒðŸ¦¤ðŸ¦šðŸ¦œðŸ¦¢ðŸ¦©ðŸ•ŠðŸ‡ðŸ¦ðŸ¦¨ðŸ¦¡ðŸ¦«ðŸ¦¦ðŸ¦¥ðŸðŸ€ðŸ¿ðŸ¦”',
        plants: 'ðŸŒµðŸŽ„ðŸŒ²ðŸŒ³ðŸŒ´ðŸª¹ðŸªºðŸªµðŸŒ±ðŸŒ¿â˜˜ï¸ðŸ€ðŸŽðŸª´ðŸŽ‹ðŸƒðŸ‚ðŸðŸ„ðŸŒ¾ðŸ’ðŸŒ·ðŸŒ¹ðŸ¥€ðŸŒºðŸŒ¸ðŸŒ¼ðŸŒ»',
        weather: 'ðŸŒžðŸŒðŸŒ›ðŸŒœðŸŒšðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ™ðŸŒŽðŸŒðŸŒðŸªðŸ’«â­ï¸ðŸŒŸâœ¨âš¡ï¸â˜„ï¸ðŸ’¥ðŸ”¥ðŸŒªðŸŒˆâ˜€ï¸ðŸŒ¤â›…ï¸ðŸŒ¥â˜ï¸ðŸŒ¦ðŸŒ§â›ˆðŸŒ©ðŸŒ¨â„ï¸â˜ƒï¸â›„ï¸ðŸŒ¬ðŸ’¨ðŸ’§ðŸ’¦â˜”ï¸â˜‚ï¸'
      },
      FOOD: {
        name: 'Food & Drink',
        all: 'ðŸðŸŽðŸðŸŠðŸ‹ðŸŒðŸ‰ðŸ‡ðŸ“ðŸ«ðŸˆðŸ’ðŸ‘ðŸ¥­ðŸðŸ¥¥ðŸ¥ðŸ…ðŸ†ðŸ¥‘ðŸ¥¦ðŸ¥¬ðŸ¥’ðŸŒ¶ðŸ«‘ðŸŒ½ðŸ¥•ðŸ«’ðŸ§„ðŸ§…ðŸ¥”ðŸ ðŸ¥ðŸ¥¯ðŸžðŸ¥–ðŸ¥¨ðŸ§€ðŸ¥šðŸ³ðŸ§ˆðŸ¥žðŸ§‡ðŸ¥“ðŸ¥©ðŸ—ðŸ–ðŸ¦´ðŸŒ­ðŸ”ðŸŸðŸ•ðŸ«“ðŸ¥ªðŸ¥™ðŸ§†ðŸŒ®ðŸŒ¯ðŸ«”ðŸ¥—ðŸ¥˜ðŸ«•ðŸ¥«ðŸðŸœðŸ²ðŸ›ðŸ£ðŸ±ðŸ¥ŸðŸ¦ªðŸ¤ðŸ™ðŸšðŸ˜ðŸ¥ðŸ¥ ðŸ¥®ðŸ¢ðŸ¡ðŸ§ðŸ¨ðŸ¦ðŸ¥§ðŸ§ðŸ°ðŸŽ‚ðŸ®ðŸ­ðŸ¬ðŸ«ðŸ¿ðŸªðŸŒ°ðŸ¥œðŸ«˜ðŸ¯ðŸ¥›â˜•ï¸ðŸ«–ðŸµðŸ§ƒðŸ¥¤ðŸ§‹ðŸ¶ðŸºðŸ»ðŸ¥‚ðŸ·ðŸ¥ƒðŸ¸ðŸ¹ðŸ§‰ðŸ¾ðŸ§ŠðŸ¥„ðŸ´ðŸ½ðŸ¥£ðŸ¥¡ðŸ¥¢ðŸ§‚'
      },
      ACTIVITIES: {
        name: 'Activities',
        all: 'âš½ï¸ðŸ€ðŸˆâš¾ï¸ðŸ¥ŽðŸŽ¾ðŸðŸ‰ðŸ¥ðŸŽ±ðŸª€ðŸ“ðŸ¸ðŸ’ðŸ‘ðŸ¥ðŸðŸªƒðŸ¥…â›³ï¸ðŸªðŸ¹ðŸŽ£ðŸ¤¿ðŸ¥ŠðŸ¥‹ðŸŽ½ðŸ›¹ðŸ›¼ðŸ›·â›¸ðŸ¥ŒðŸŽ¿â›·ðŸ‚ðŸª‚ðŸ‹ï¸â€â™€ï¸ðŸ‹ï¸ðŸ‹ï¸â€â™‚ï¸ðŸ¤¼â€â™€ï¸ðŸ¤¼ðŸ¤¼â€â™‚ï¸ðŸ¤¸â€â™€ï¸ðŸ¤¸ðŸ¤¸â€â™‚ï¸â›¹ï¸â€â™€ï¸â›¹ï¸â›¹ï¸â€â™‚ï¸ðŸ¤ºðŸ¤¾â€â™€ï¸ðŸ¤¾ðŸ¤¾â€â™‚ï¸ðŸŒï¸â€â™€ï¸ðŸŒï¸ðŸŒï¸â€â™‚ï¸ðŸ‡ðŸ§˜â€â™€ï¸ðŸ§˜ðŸ§˜â€â™‚ï¸ðŸ„â€â™€ï¸ðŸ„ðŸ„â€â™‚ï¸ðŸŠâ€â™€ï¸ðŸŠðŸŠâ€â™‚ï¸ðŸ¤½â€â™€ï¸ðŸ¤½ðŸ¤½â€â™‚ï¸ðŸš£â€â™€ï¸ðŸš£ðŸš£â€â™‚ï¸ðŸ§—â€â™€ï¸ðŸ§—ðŸ§—â€â™‚ï¸ðŸšµâ€â™€ï¸ðŸšµðŸšµâ€â™‚ï¸ðŸš´â€â™€ï¸ðŸš´ðŸš´â€â™‚ï¸ðŸŽªðŸ¤¹â€â™€ï¸ðŸ¤¹ðŸ¤¹â€â™‚ï¸ðŸŽ­ðŸŽ¨ðŸŽ¬ðŸŽ¤ðŸŽ§ðŸŽ¼ðŸŽ¹ðŸ¥ðŸª˜ðŸŽ·ðŸŽºðŸª—ðŸŽ¸ðŸª•ðŸŽ»ðŸŽ²â™ŸðŸŽ¯ðŸŽ³ðŸŽ®ðŸŽ°ðŸ§©'
      },
      TRAVEL: {
        name: 'Travel & Places',
        all: 'ðŸš—ðŸš•ðŸš™ðŸšŒðŸšŽðŸš“ðŸš‘ðŸš’ðŸšðŸ›»ðŸššðŸš›ðŸšœðŸ¦¯ðŸ¦½ðŸ¦¼ðŸ›´ðŸš²ðŸ›µðŸðŸ›ºðŸš¨ðŸš”ðŸšðŸš˜ðŸš–ðŸš¡ðŸš ðŸšŸðŸšƒðŸš‹ðŸšžðŸšðŸš„ðŸš…ðŸšˆðŸš‚ðŸš†ðŸš‡ðŸšŠðŸš‰âœˆï¸ðŸ›«ðŸ›¬ðŸ›©ðŸ’ºðŸ›°ðŸš€ðŸ›¸ðŸšðŸ›¶â›µï¸ðŸš¤ðŸ›¥ðŸ›³â›´ðŸš¢âš“ï¸ðŸªâ›½ï¸ðŸš§ðŸš¦ðŸš¥ðŸšðŸ—ºðŸ—¿ðŸ—½ðŸ—¼ðŸ°ðŸ¯ðŸŸðŸŽ¡ðŸŽ¢ðŸŽ â›²ï¸â›±ðŸ–ðŸðŸœðŸŒ‹â›°ðŸ”ðŸ—»ðŸ•â›ºï¸ðŸ ðŸ¡ðŸ˜ðŸšðŸ—ðŸ­ðŸ¢ðŸ¬ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ¨ðŸªðŸ«ðŸ©ðŸ’’ðŸ›â›ªï¸ðŸ•ŒðŸ•ðŸ›•ðŸ•‹â›©ðŸ›¤ðŸ›£ðŸ—¾ðŸŽ‘ðŸžðŸŒ…ðŸŒ„ðŸŒ ðŸŽ‡ðŸŽ†ðŸŒ‡ðŸŒ†ðŸ™ðŸŒƒðŸŒŒðŸŒ‰ðŸŒ'
      },
      OBJECTS: {
        name: 'Objects',
        tech: 'âŒšï¸ðŸ“±ðŸ“²ðŸ’»âŒ¨ï¸ðŸ–¥ðŸ–¨ðŸ–±ðŸ–²ðŸ•¹ðŸ—œðŸ’½ðŸ’¾ðŸ’¿ðŸ“€ðŸ“¼ðŸ“·ðŸ“¸ðŸ“¹ðŸŽ¥ðŸ“½ðŸŽžðŸ“žâ˜Žï¸ðŸ“ŸðŸ“ ðŸ“ºðŸ“»ðŸŽ™ðŸŽšðŸŽ›ðŸ§­â±â²â°ðŸ•°âŒ›ï¸â³ðŸ“¡',
        household: 'ðŸ”‹ðŸ”ŒðŸ’¡ðŸ”¦ðŸ•¯ðŸª”ðŸ§¯ðŸ›¢ðŸ’¸ðŸ’µðŸ’´ðŸ’¶ðŸ’·ðŸª™ðŸ’°ðŸ’³ðŸ’Žâš–ï¸ðŸªœðŸ§°ðŸª›ðŸ”§ðŸ”¨âš’ðŸ› â›ðŸªšðŸ”©âš™ï¸ðŸª¤ðŸ§±â›“ðŸ§²ðŸ”«ðŸ’£ðŸ§¨ðŸª“ðŸ”ªðŸ—¡âš”ï¸ðŸ›¡',
        personal: 'ðŸ’ˆâš—ï¸ðŸ”­ðŸ”¬ðŸ•³ðŸ©¹ðŸ©ºðŸ’ŠðŸ’‰ðŸ©¸ðŸ§¬ðŸ¦ ðŸ§«ðŸ§ªðŸŒ¡ðŸ§¹ðŸª ðŸ§ºðŸ§»ðŸš½ðŸš°ðŸš¿ðŸ›ðŸ›€ðŸ§¼ðŸª¥ðŸª’ðŸ§½ðŸª£ðŸ§´ðŸ’„ðŸ’ðŸ’…',
        furniture: 'ðŸ›ŽðŸ”‘ðŸ—ðŸšªðŸª‘ðŸ›‹ðŸ›ðŸ›ŒðŸ§¸ðŸª†ðŸ–¼ðŸªžðŸªŸðŸ›ðŸ›’',
        celebration: 'ðŸŽðŸŽˆðŸŽðŸŽ€ðŸª„ðŸª…ðŸŽŠðŸŽ‰ðŸŽŽðŸ®ðŸŽðŸ§§',
        stationery: 'âœ‰ï¸ðŸ“©ðŸ“¨ðŸ“§ðŸ’ŒðŸ“¥ðŸ“¤ðŸ“¦ðŸ·ðŸª§ðŸ“ªðŸ“«ðŸ“¬ðŸ“­ðŸ“®ðŸ“¯ðŸ“œðŸ“ƒðŸ“„ðŸ“‘ðŸ§¾ðŸ“ŠðŸ“ˆðŸ“‰ðŸ—’ðŸ—“ðŸ“†ðŸ“…ðŸ—‘ðŸ“‡ðŸ—ƒðŸ—³ðŸ—„ðŸ“‹ðŸ“ðŸ“‚ðŸ—‚ðŸ—žðŸ“°ðŸ““ðŸ“”ðŸ“’ðŸ“•ðŸ“—ðŸ“˜ðŸ“™ðŸ“šðŸ“–ðŸ”–ðŸ§·ðŸ”—ðŸ“ŽðŸ–‡ðŸ“ðŸ“âœ‚ï¸ðŸ–ŠðŸ–‹âœ’ï¸ðŸ–ŒðŸ–ðŸ“'
      },

      SYMBOLS: {
        name: 'Symbols',
        hearts: 'â¤ï¸ðŸ§¡ðŸ’›ðŸ’šðŸ’™ðŸ’œðŸ–¤ðŸ¤ðŸ¤ŽðŸ’”â£ï¸ðŸ’•ðŸ’žðŸ’“ðŸ’—ðŸ’–ðŸ’˜ðŸ’ðŸ’Ÿ',
        spiritual: 'â˜®ï¸âœï¸â˜ªï¸ðŸ•‰â˜¸ï¸âœ¡ï¸ðŸ”¯ðŸ•Žâ˜¯ï¸â˜¦ï¸ðŸ›â›Žâ™ˆï¸â™‰ï¸â™Šï¸â™‹ï¸â™Œï¸â™ï¸â™Žï¸â™ï¸â™ï¸â™‘ï¸â™’ï¸â™“ï¸',
        warning: 'âš ï¸ðŸš¸â›”ï¸ðŸš«ðŸš­ðŸš¯ðŸš³ðŸš±ðŸ”žðŸ“µâŒâœ–ï¸â—ï¸â•â“â”â€¼ï¸â‰ï¸ã€½ï¸',
        numbers: '0ï¸âƒ£1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£4ï¸âƒ£5ï¸âƒ£6ï¸âƒ£7ï¸âƒ£8ï¸âƒ£9ï¸âƒ£ðŸ”ŸðŸ’¯',
        info: 'ðŸ†”â„¹ï¸â“‚ï¸ðŸ…¿ï¸ðŸ”°â™»ï¸âœ…âŽðŸŒðŸ’ ðŸ”…ðŸ”†ðŸˆðŸˆ‚ï¸ðŸˆ·ï¸ðŸˆ¶ðŸˆ¯ï¸ðŸˆšï¸ðŸˆ¸ðŸˆºãŠ—ï¸ãŠ™ï¸ðŸˆ´ðŸˆµðŸˆ¹ðŸˆ²ðŸ…°ï¸ðŸ…±ï¸ðŸ†ŽðŸ†‘ðŸ…¾ï¸ðŸ†˜',
        geometric: 'â¬›ï¸â¬œï¸ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ©ðŸŸ¦ðŸŸªðŸŸ«âš«ï¸âšªï¸ðŸ”´ðŸ”µðŸŸ¡ðŸŸ¢ðŸ”¶ðŸ”·â—¼ï¸â—»ï¸',
        sound: 'ðŸ”ˆðŸ”‡ðŸ”‰ðŸ”ŠðŸ””ðŸ”•ðŸ“£ðŸ“¢ðŸ’¬ðŸ’­ðŸ—¯',
        misc: 'â™ ï¸â™£ï¸â™¥ï¸â™¦ï¸ðŸƒðŸŽ´ðŸ€„ï¸ðŸ•ðŸ•‘ðŸ•’ðŸ•“ðŸ•”ðŸ••ðŸ•–ðŸ•—ðŸ•˜ðŸ•™ðŸ•šðŸ•›ðŸ³ï¸ðŸ´ðŸðŸš©ðŸ³ï¸â€ðŸŒˆðŸ³ï¸â€âš§ï¸ðŸ´â€â˜ ï¸',
        indicators: '#ï¸âƒ£*ï¸âƒ£Â©ï¸Â®ï¸â„¢ï¸ã€°ï¸âœ³ï¸âœ´ï¸âž•âž–âž—âœ–ï¸â™¾ðŸ’²ðŸ’±â†—ï¸â†˜ï¸â†™ï¸â†–ï¸â†•ï¸â†”ï¸â¤´ï¸â¤µï¸ðŸ”„ðŸ”ƒ'
      }
    };

    const initializeEmojiPalette = {
      generatePalette: (selectedCategories = ['ALL']) => {
        const palette = new Set();

        const addToSet = (emoji) => {
          if (checkEmojiWidth(emoji)) {
            palette.add(emoji);
          }
        };

        // If no categories selected, return empty set
        if (selectedCategories.length === 0) {
          return [];
        }

        // Get categories to process
        const categoriesToProcess = selectedCategories.includes('ALL')
          ? Object.keys(EMOJI_CATEGORIES).filter(key => key !== 'ALL')
          : selectedCategories;

        // Process selected categories
        categoriesToProcess.forEach(categoryKey => {
          const category = EMOJI_CATEGORIES[categoryKey];
          if (category) {
            Object.entries(category).forEach(([subKey, content]) => {
              if (typeof content === 'string' && subKey !== 'name') {
                const emojis = Array.from(content);
                if (subKey === 'toneSupport') {
                  emojis.forEach(emoji => {
                    addToSet(emoji);
                    ['ðŸ»', 'ðŸ¼', 'ðŸ½', 'ðŸ¾', 'ðŸ¿'].forEach(tone => {
                      addToSet(emoji + tone);
                    });
                  });
                } else {
                  emojis.forEach(emoji => addToSet(emoji));
                }
              }
            });
          }
        });

        return Array.from(palette);
      }
    };

    /* Simplified EmojiControls component */
    const EmojiControls = ({ onRegeneratePalette, selectedCategories, onCategoryChange }) => {
      return h('div', { className: 'space-y-2 mb-4' }, [
        h('label', { className: 'block text-sm font-medium' }, 'Emoji Categories:'),
        h('div', { className: 'flex flex-wrap gap-2' },
          Object.entries(EMOJI_CATEGORIES).map(([key, category]) =>
            h('label', { className: 'inline-flex items-center', key }, [
              h('input', {
                type: 'checkbox',
                checked: selectedCategories.includes(key),
                onChange: (e) => {
                  let newCategories;
                  if (key === 'ALL') {
                    newCategories = e.target.checked ? ['ALL'] : [];
                  } else {
                    if (e.target.checked) {
                      // Remove ALL if present and add the new category
                      newCategories = [
                        ...selectedCategories.filter(c => c !== 'ALL'),
                        key
                      ];
                    } else {
                      newCategories = selectedCategories.filter(c => c !== key);
                    }
                  }
                  localStorage.removeItem('emojiColors');
                  onCategoryChange(newCategories);
                },
                className: 'mr-2'
              }),
              category.name
            ])
          )
        ),
        h('button', {
          onClick: onRegeneratePalette,
          className: 'mt-4 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600'
        }, 'Reset Emoji Palette')
      ]);
    };

    /* Helper function to apply skin tones to supported emojis */
    const applySkinTones = (emoji) => {
      const tones = ['ðŸ»', 'ðŸ¼', 'ðŸ½', 'ðŸ¾', 'ðŸ¿'];
      return [emoji, ...tones.map(tone => emoji + tone)];
    };

    /* Get all emojis for a category, applying skin tones where supported */
    const getEmojisForCategory = (category) => {
      if (category === EMOJI_CATEGORIES.FACES_AND_PEOPLE) {
        const baseEmojis = category.base.split('');
        const toneSupportEmojis = category.toneSupport.split('').flatMap(applySkinTones);
        return [...baseEmojis, ...toneSupportEmojis];
      }

      return Object.values(category)
        .filter(value => typeof value === 'string' && value !== category.name)
        .flatMap(str => str.split(''));
    };



    const ColorIndex = {
      createIndex(emojiColors, backgroundColor) {
        const bgRgb = hexToRgb(backgroundColor);
        const blendFactor = 0.8;

        const index = {
          lab: new Map(),
          sorted: []
        };

        /* Pre-compute blended LAB values */
        Object.entries(emojiColors).forEach(([emoji, rawRgb]) => {
          const blendedRgb = [
            Math.round(rawRgb[0] * blendFactor + bgRgb[0] * (1 - blendFactor)),
            Math.round(rawRgb[1] * blendFactor + bgRgb[1] * (1 - blendFactor)),
            Math.round(rawRgb[2] * blendFactor + bgRgb[2] * (1 - blendFactor))
          ];

          const labColor = rgbToLab(...blendedRgb);
          index.lab.set(emoji, labColor);
          index.sorted.push([emoji, labColor]);
        });

        /* Sort by all LAB components for better matching */
        index.sorted.sort(([, lab1], [, lab2]) => {
          const [l1, a1, b1] = lab1;
          const [l2, a2, b2] = lab2;
          return l1 - l2 || a1 - a2 || b1 - b2;
        });

        return index;
      },

      findSimilar(index, targetLab, threshold = 5) {
  const [l] = targetLab;
  let pos = index.sorted.findIndex(([, lab]) => lab[0] >= l);
  if (pos < 0) pos = index.sorted.length - 1;

  /* Single scan collecting all matches and their scores */
  const matches = [];
  let bestMatch = [null, Infinity];

  /* Scan in both directions, tracking both threshold matches and overall best */
  for (let i = pos; i >= 0 && matches.length < 50; i--) {
    const [emoji, lab] = index.sorted[i];
    const diff = Math.sqrt(
      Math.pow(lab[0] - targetLab[0], 2) +
      Math.pow(lab[1] - targetLab[1], 2) +
      Math.pow(lab[2] - targetLab[2], 2)
    );
    if (diff <= threshold * 3) {
      matches.push([emoji, diff]);
    }
    if (diff < bestMatch[1]) {
      bestMatch = [emoji, diff];
    }
  }

  for (let i = pos + 1; i < index.sorted.length && matches.length < 50; i++) {
    const [emoji, lab] = index.sorted[i];
    const diff = Math.sqrt(
      Math.pow(lab[0] - targetLab[0], 2) +
      Math.pow(lab[1] - targetLab[1], 2) +
      Math.pow(lab[2] - targetLab[2], 2)
    );
    if (diff <= threshold * 3) {
      matches.push([emoji, diff]);
    }
    if (diff < bestMatch[1]) {
      bestMatch = [emoji, diff];
    }
  }

  /* If we found matches within threshold, randomly select from best matches */
  if (matches.length > 0) {
    matches.sort((a, b) => a[1] - b[1]);
    const bestDiff = matches[0][1];
    const candidates = matches.filter(m => m[1] <= bestDiff * 1.05);
    return candidates[Math.floor(Math.random() * candidates.length)][0];
  }

  /* Otherwise return the single best match we found during our scan */
  return bestMatch[0];
}};

    /* Singleton for managing the emoji palette and color index */
    const EmojiPaletteManager = {
      _palette: null,
      _colorIndices: new Map(), // Cache color indices by background color
      _loadingPromise: null,

      /* Initialize or return cached palette */
      async getPalette() {
        if (this._palette) return this._palette;
        if (this._loadingPromise) return this._loadingPromise;

        const cached = localStorage.getItem('emojiPalette');
        if (cached) {
          this._palette = JSON.parse(cached);
          return this._palette;
        }

        this._loadingPromise = this._generatePalette();
        this._palette = await this._loadingPromise;
        this._loadingPromise = null;
        return this._palette;
      },

      /* Generate the complete emoji palette once */
      async _generatePalette() {
        const allEmojis = new Set();

        // Process all categories
        Object.entries(EMOJI_CATEGORIES).forEach(([key, category]) => {
          if (key === 'ALL') return;

          Object.entries(category).forEach(([subKey, content]) => {
            if (typeof content === 'string' && subKey !== 'name') {
              const emojis = Array.from(content);
              if (subKey === 'toneSupport') {
                emojis.forEach(emoji => {
                  if (checkEmojiWidth(emoji)) {
                    allEmojis.add(emoji);
                    ['ðŸ»', 'ðŸ¼', 'ðŸ½', 'ðŸ¾', 'ðŸ¿'].forEach(tone => {
                      const tonedEmoji = emoji + tone;
                      if (checkEmojiWidth(tonedEmoji)) {
                        allEmojis.add(tonedEmoji);
                      }
                    });
                  }
                });
              } else {
                emojis.forEach(emoji => {
                  if (checkEmojiWidth(emoji)) {
                    allEmojis.add(emoji);
                  }
                });
              }
            }
          });
        });

        // Extract colors for all emojis
        const palette = {};
        let processed = 0;
        const total = allEmojis.size;

        for (const emoji of allEmojis) {
          palette[emoji] = await extractEmojiColor(emoji);
          processed++;
          if (this.onProgress) {
            this.onProgress(Math.floor((processed / total) * 100));
          }
        }

        localStorage.setItem('emojiPalette', JSON.stringify(palette));
        return palette;
      },

      /* Get or create color index for specific categories and background */
      async getColorIndex(selectedCategories, backgroundColor) {
        const key = `${selectedCategories.sort().join(',')}:${backgroundColor}`;
        if (this._colorIndices.has(key)) {
          return this._colorIndices.get(key);
        }

        const fullPalette = await this.getPalette();
        const filteredPalette = {};

        // Filter palette based on selected categories
        const allowedEmojis = new Set();
        if (selectedCategories.includes('ALL')) {
          Object.keys(fullPalette).forEach(emoji => allowedEmojis.add(emoji));
        } else {
          selectedCategories.forEach(categoryKey => {
            const category = EMOJI_CATEGORIES[categoryKey];
            if (category) {
              Object.entries(category).forEach(([subKey, content]) => {
                if (typeof content === 'string' && subKey !== 'name') {
                  Array.from(content).forEach(emoji => {
                    if (allowedEmojis.has(emoji)) return;
                    allowedEmojis.add(emoji);
                    if (subKey === 'toneSupport') {
                      ['ðŸ»', 'ðŸ¼', 'ðŸ½', 'ðŸ¾', 'ðŸ¿'].forEach(tone => {
                        allowedEmojis.add(emoji + tone);
                      });
                    }
                  });
                }
              });
            }
          });
        }

        // Create filtered palette
        for (const emoji of allowedEmojis) {
          if (fullPalette[emoji]) {
            filteredPalette[emoji] = fullPalette[emoji];
          }
        }

        const index = ColorIndex.createIndex(filteredPalette, backgroundColor);
        this._colorIndices.set(key, index);
        return index;
      },

      /* Clear all cached data */
      clearCache() {
        localStorage.removeItem('emojiPalette');
        this._palette = null;
        this._colorIndices.clear();
      },

      onProgress: null // Progress callback
    };

    /*  
      Suggest a background color by averaging the pixels along the imageâ€™s borders.
    */
    const suggestBackgroundColor = (imageData) => {
      const data = imageData.data;
      const { width, height } = imageData;
      let totalR = 0, totalG = 0, totalB = 0, count = 0;
      const borderWidth = Math.min(10, Math.floor(width * 0.05), Math.floor(height * 0.05));
      for (let y = 0; y < borderWidth; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          totalR += data[idx];
          totalG += data[idx + 1];
          totalB += data[idx + 2];
          count++;
        }
      }
      for (let y = height - borderWidth; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          totalR += data[idx];
          totalG += data[idx + 1];
          totalB += data[idx + 2];
          count++;
        }
      }
      for (let y = borderWidth; y < height - borderWidth; y++) {
        for (let x = 0; x < borderWidth; x++) {
          const idx = (y * width + x) * 4;
          totalR += data[idx];
          totalG += data[idx + 1];
          totalB += data[idx + 2];
          count++;
        }
        for (let x = width - borderWidth; x < width; x++) {
          const idx = (y * width + x) * 4;
          totalR += data[idx];
          totalG += data[idx + 1];
          totalB += data[idx + 2];
          count++;
        }
      }
      if (!count) return "#ffffff";
      const toHex = c => c.toString(16).padStart(2, '0');
      return `#${toHex(Math.round(totalR / count))}${toHex(Math.round(totalG / count))}${toHex(Math.round(totalB / count))}`;
    };


    /************************* App component *************************/

    const App = () => {
      const [imageData, setImageData] = useState(null);
      const [resolution, setResolution] = useState({ width: 32, height: 32 });
      const [selectedCategories, setSelectedCategories] = useState(['ALL']);
      const [processedPalette, setProcessedPalette] = useState({});
      const [collage, setCollage] = useState([]);
      const [originalImage, setOriginalImage] = useState(null);
      const [paletteProgress, setPaletteProgress] = useState(0);
      const [colorIndex, setColorIndex] = useState(null);
      const [readyToRender, setReadyToRender] = useState(false);
      const canvasRef = useRef(null);
      const [processing, setProcessing] = useState(false);
      const [zoomLevel, setZoomLevel] = useState(1);
      const [bgColor, setBgColor] = useState('#ffffff');


      useEffect(() => {
        if (selectedCategories.length === 0) {
          setColorIndex(null);
          return;
        }

        EmojiPaletteManager.onProgress = setPaletteProgress;
        EmojiPaletteManager.getColorIndex(selectedCategories, bgColor)
          .then(index => {
            setColorIndex(index);
            // Update processed palette for preview
            const filteredPalette = {};
            index.sorted.forEach(([emoji]) => {
              filteredPalette[emoji] = EmojiPaletteManager._palette[emoji];
            });
            setProcessedPalette(filteredPalette);
          });
      }, [selectedCategories, bgColor]);


      useEffect(() => {
        const handleResize = () => {
          if (zoomLevel > calculateMaxZoom()) {
            setZoomLevel(calculateMaxZoom());
          }
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, [collage, resolution, zoomLevel]);



      const calculateResolution = (w, h) => {
        const minDimension = 32;
        const aspectRatio = w / h;
        return w < h
          ? { width: minDimension, height: Math.round(minDimension / aspectRatio) }
          : { width: Math.round(minDimension * aspectRatio), height: minDimension };
      };

      const updateResolution = (newW, newH, isWidth) => {
        if (!originalImage || !canvasRef.current) return;
        const aspect = originalImage.width / originalImage.height;
        let updatedW, updatedH;
        if (isWidth) {
          updatedW = newW;
          updatedH = Math.round(newW / aspect);
        } else {
          updatedH = newH;
          updatedW = Math.round(newH * aspect);
        }
        setResolution({ width: updatedW, height: updatedH });
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = updatedW;
        canvas.height = updatedH;
        ctx.drawImage(originalImage, 0, 0, updatedW, updatedH);
        setImageData(ctx.getImageData(0, 0, updatedW, updatedH));
        setCollage([]);
        setReadyToRender(true);
      };

      const handleImageUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
          const img = new Image();
          img.onload = () => {
            setOriginalImage(img);
            const newRes = calculateResolution(img.width, img.height);
            setResolution(newRes);
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = newRes.width;
            canvas.height = newRes.height;
            ctx.drawImage(img, 0, 0, newRes.width, newRes.height);
            const imgData = ctx.getImageData(0, 0, newRes.width, newRes.height);
            setImageData(imgData);
            const suggested = suggestBackgroundColor(imgData);
            setBgColor(suggested);
            setCollage([]);
            setReadyToRender(true);
          };
          img.onerror = (err) => console.error('Image load error:', err);
          img.src = evt.target.result;
        };
        reader.onerror = (err) => console.error('File read error:', err);
        reader.readAsDataURL(file);
      };

      /*  
        Generate the collage.
        For each image pixel, we:
        1. Convert the pixelâ€™s color to LAB.
        2. Find the closest emoji in the Color Index based on LAB distance. 
      */
      const generateCollage = () => {
        if (!imageData || !colorIndex) {
          console.error('Missing data:', { hasImageData: !!imageData, colorIndex });
          return;
        }
        console.log('Starting generation with colorIndex:', colorIndex);

        setProcessing(true);
        const data = imageData.data;
        const newCollage = [];

        for (let y = 0; y < resolution.height; y++) {
          const row = [];
          for (let x = 0; x < resolution.width; x++) {
            const i = (y * resolution.width + x) * 4;
            const labColor = rgbToLab(data[i], data[i + 1], data[i + 2]);
            // Add debug log for first pixel
            if (x === 0 && y === 0) {
              console.log('First pixel:', {
                rgb: [data[i], data[i + 1], data[i + 2]],
                lab: labColor,
                colorIndex: colorIndex
              });
            }
            const emoji = ColorIndex.findSimilar(colorIndex, labColor);
            row.push(emoji);
          }
          newCollage.push(row);
        }

        setCollage(newCollage);
        setProcessing(false);
      };

      const downloadPNG = () => {
        if (!collage.length) return;
        const tempCanvas = document.createElement('canvas');
        const scale = 30;
        tempCanvas.width = resolution.width * scale;
        tempCanvas.height = resolution.height * scale;
        const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        ctx.font = `${scale}px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"`;
        ctx.textBaseline = 'top';
        for (let y = 0; y < resolution.height; y++) {
          for (let x = 0; x < resolution.width; x++) {
            ctx.fillText(collage[y][x], x * scale, y * scale);
          }
        }
        tempCanvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'emoji_collage.png';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 'image/png');
      };

      const downloadSVG = () => {
        if (!collage.length) return;
        const emojiSize = 20;
        const svgW = resolution.width * emojiSize;
        const svgH = resolution.height * emojiSize;

        let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}">`;
        svgContent += `<rect width="100%" height="100%" fill="${bgColor}"/>`;
        svgContent += `<text font-size="${emojiSize}" font-family="Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, Android Emoji">`;

        for (let y = 0; y < resolution.height; y++) {
          for (let x = 0; x < resolution.width; x++) {
            svgContent += `<tspan x="${x * emojiSize}" y="${(y + 1) * emojiSize}">${collage[y][x]}</tspan>`;
          }
        }

        svgContent += '</text></svg>';
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'emoji_collage.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      const openFullPage = () => {
        if (!collage.length) return;
        const baseFontSize = Math.max(6, Math.min(32, 800 / resolution.width));
        const effectiveFontSize = baseFontSize * zoomLevel;
        const htmlContent = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <title>Emoji Collage</title>
        <style>
          body { 
            margin: 0; 
            padding: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            background-color: ${bgColor}; 
          }
          .emoji-grid {
              display: block;
              font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji";
              line-height: 1em; 
              letter-spacing: -0.4em;
          }

        </style>
      </head>
      <body>
        <div class="emoji-grid">
          ${collage.map(row => `<div class="emoji-row">${row.join('')}</div>`).join('\n')}
        </div>
      </body>
      </html>
    `;
        const newWindow = window.open('', '_blank');
        if (newWindow) {
          newWindow.document.open();
          newWindow.document.write(htmlContent);
          newWindow.document.close();
        } else {
          alert('Pop-up blocked. Please allow pop-ups for this website.');
        }
      };

      const calculateMaxZoom = () => {
        if (!collage.length || !resolution) return 3;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight * 0.8; // 70% of viewport height to account for controls
        const baseFontSize = Math.max(8, Math.min(64, 1000 / resolution.width));
        const maxWidthZoom = viewportWidth / (resolution.width * baseFontSize);
        const maxHeightZoom = viewportHeight / (resolution.height * baseFontSize);
        return Math.max(1, Math.min(maxWidthZoom, maxHeightZoom, 4));
      };

      const increaseZoom = () => {
        const maxZoom = calculateMaxZoom();
        setZoomLevel(prev => Math.min(prev + 0.1, maxZoom));
      };

      const decreaseZoom = () => setZoomLevel(prev => Math.max(prev - 0.1, 0.2));

      const resetZoom = () => {
        const maxZoom = calculateMaxZoom();
        setZoomLevel(Math.min(1, maxZoom));
      };
      // Render the collage preview
      const renderCollagePreview = () => {
        if (collage.length > 0) {
          const baseFontSize = Math.max(8, Math.min(32, 800 / resolution.width));
          const effectiveFontSize = baseFontSize * zoomLevel;
          return h('div', {
            className: 'collage-container',
            style: {
              width: (resolution.width * effectiveFontSize) + 'px',
              height: (resolution.height * effectiveFontSize) + 'px',
              backgroundColor: bgColor
            }
          }, [
            h('div', {
              className: 'emoji-grid',
              style: { fontSize: effectiveFontSize + 'px' }
            },
              collage.map((row, rowIndex) =>
                h('div', {
                  key: rowIndex,
                  className: 'emoji-row'
                }, row.join(''))
              )
            )
          ]);
        }
        return null;
      };

      // Render the palette preview
      const renderPalettePreview = () => {
        if (paletteProgress < 100) {
          const keys = Object.keys(processedPalette);
          const sample = keys.length <= 50 ? keys : keys.slice(-50);
          return h('div', { className: 'mt-4' }, [
            h('h2', { className: 'text-md font-medium mb-2' }, 'Palette Processing Preview:'),
            h('div', { className: 'grid grid-cols-10 gap-1' },
              sample.map(emoji => {
                const color = processedPalette[emoji];
                return h('div', {
                  key: emoji,
                  style: {
                    backgroundColor: color ? `rgb(${color[0]}, ${color[1]}, ${color[2]})` : '#fff',
                    border: '1px solid #ccc',
                    width: '2em',
                    height: '2em',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }
                }, emoji);
              })
            )
          ]);
        }
        return null;
      };

      // Render the lower section
      const renderLowerSection = () => {
        return h('div', { style: { backgroundColor: bgColor, width: '100%' } }, [
          h('div', { className: 'p-6 max-w-6xl mx-auto' }, [
            h('div', { className: 'bg-white p-4 rounded shadow mt-4 flex flex-col gap-4' }, [
              originalImage && h('button', {
                onClick: generateCollage,
                className: 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50',
                disabled: processing || paletteProgress < 100
              }, paletteProgress < 100 ? 'Building Emoji Palette...' : (processing ? 'Generating...' : 'Generate Collage')),
              collage.length > 0 && h('div', { className: 'controls-row' }, [
                h('button', { onClick: downloadPNG, className: 'px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600' }, 'Download as PNG'),
                h('button', { onClick: downloadSVG, className: 'px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600' }, 'Download as SVG'),
                h('button', { onClick: openFullPage, className: 'px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600' }, 'Open as Full Page'),
                h('button', { onClick: decreaseZoom, className: 'zoom-button', title: 'Zoom Out' }, '-'),
                h('button', { onClick: resetZoom, className: 'zoom-button', title: 'Reset' }, 'Reset'),
                h('button', { onClick: increaseZoom, className: 'zoom-button', title: 'Zoom In' }, '+')
              ])
            ]),
            renderCollagePreview(),
            h('div', { className: 'mt-6 text-center text-sm text-gray-500' }, 'Â© 2025 Emoji Collage Maker')
          ])
        ]);
      };

      // Main return statement for the App component
      return h('div', { className: 'p-6 max-w-6xl mx-auto' }, [
        h('h1', { className: 'text-4xl font-bold mb-6 text-center' }, 'Emoji Collage Maker'),
        h('div', { className: 'bg-white p-4 rounded shadow' }, [
          h('div', { className: 'flex flex-wrap gap-4' }, [
            h('div', { className: 'flex-1 min-w-[250px]' }, [
              h('div', { className: 'space-y-2 mb-4' }, [
                h('label', { className: 'block text-sm font-medium' }, 'Upload Image:'),
                h('input', {
                  type: 'file',
                  accept: 'image/*',
                  onChange: handleImageUpload,
                  className: 'block w-full text-sm text-gray-500'
                })
              ]),
              originalImage && h('div', { className: 'space-y-2 mb-4' }, [
                h('label', { className: 'block text-sm font-medium' }, 'Resolution:'),
                h('div', { className: 'flex gap-2 items-center' }, [
                  h('input', {
                    type: 'number',
                    value: resolution.width,
                    onChange: (e) => updateResolution(+e.target.value, resolution.height, true),
                    className: 'w-20 px-2 py-1 border rounded'
                  }),
                  h('span', null, 'Ã—'),
                  h('input', {
                    type: 'number',
                    value: resolution.height,
                    onChange: (e) => updateResolution(resolution.width, +e.target.value, false),
                    className: 'w-20 px-2 py-1 border rounded'
                  })
                ])
              ]),
              originalImage && h('div', { className: 'space-y-2 mb-4' }, [
                h('label', { className: 'block text-sm font-medium' }, 'Background Color:'),
                h('input', {
                  type: 'color',
                  value: bgColor,
                  onChange: (e) => setBgColor(e.target.value),
                  className: 'w-12 h-12 p-0 border rounded'
                })
              ]),
              h(EmojiControls, {
                onRegeneratePalette: () => {
                  EmojiPaletteManager.clearCache();
                  window.location.reload();
                },
                selectedCategories,
                onCategoryChange: setSelectedCategories
              }),
              h('canvas', { ref: canvasRef, id: 'processingCanvas' }),
              h('div', { className: 'text-sm text-gray-600 mb-4' },
                paletteProgress < 100
                  ? `Building emoji palette: ${paletteProgress}% complete (cached for future collage generations)...`
                  : 'Emoji palette ready!'
              ),
              renderPalettePreview()
            ]),
            originalImage && h('div', { className: 'flex-shrink-0' }, [
              h('h2', { className: 'text-lg font-medium mb-2' }, 'Original Image:'),
              h('img', {
                src: originalImage.src,
                className: 'border rounded',
                style: { maxHeight: '500px', maxWidth: '100%' }
              })
            ])
          ])
        ]),
        renderLowerSection()
      ]);
    };

    /* Render the App component */
    render(h(App), document.getElementById('app'));
  </script>
</body>

</html>