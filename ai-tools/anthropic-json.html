<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude API Response Viewer</title>
    <script type="importmap">
        {
            "imports": {
                "preact": "https://esm.sh/preact@10.23.1",
                "preact/": "https://esm.sh/preact@10.23.1/",
                "htm/preact": "https://esm.sh/htm@3.1.1/preact?external=preact"
            }
        }
    </script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: #fafafa;
            color: #333;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .input-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .input-section h2 {
            margin: 0 0 15px 0;
            color: #555;
            font-size: 1.1em;
        }
        
        .gist-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .load-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .load-btn:hover {
            background: #0056b3;
        }
        
        .error {
            color: #d73027;
            background: #ffebee;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .collapsible {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .collapsible-header {
            background: #f5f5f5;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            font-weight: 500;
            user-select: none;
        }
        
        .collapsible-header:hover {
            background: #ebebeb;
        }
        
        .collapsible-content {
            padding: 15px;
            display: none;
            background: #fafafa;
        }
        
        .collapsible.expanded .collapsible-content {
            display: block;
        }
        
        .thinking-content {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        .content-section {
            margin-top: 20px;
        }
        
        .content-text {
            font-size: 16px;
            line-height: 1.8;
            margin-bottom: 16px;
        }
        
        .content-text h1, .content-text h2, .content-text h3 {
            margin: 24px 0 12px 0;
            font-weight: 600;
        }
        
        .content-text h1 { font-size: 1.5em; }
        .content-text h2 { font-size: 1.3em; }
        .content-text h3 { font-size: 1.1em; }
        
        .content-text strong, .content-text b {
            font-weight: 600;
        }
        
        .content-text ul, .content-text ol {
            padding-left: 20px;
            margin: 12px 0;
        }
        
        .content-text li {
            margin: 4px 0;
        }
        
        .content-text p {
            margin: 12px 0;
        }
        
        .citation {
            font-size: 0.8em;
            vertical-align: super;
            color: #007bff;
            text-decoration: none;
            margin: 0 1px;
        }
        
        .citation:hover {
            text-decoration: underline;
        }
        
        .search-section {
            margin-bottom: 20px;
        }
        
        .search-query {
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
        }
        
        .search-result {
            margin-bottom: 15px;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #f9f9f9;
        }
        
        .search-result h4 {
            margin: 0 0 8px 0;
            color: #1a0dab;
            font-size: 14px;
        }
        
        .search-result a {
            color: #1a0dab;
            text-decoration: none;
        }
        
        .search-result a:hover {
            text-decoration: underline;
        }
        
        .search-url {
            color: #006621;
            font-size: 12px;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .instructions {
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script type="module">
        import { render } from 'preact';
        import { html } from 'htm/preact';
        import { useState, useEffect } from 'preact/hooks';

        // Simple markdown to HTML converter
        function markdownToHtml(text) {
            if (!text) return '';
            
            // Split into lines for better processing
            const lines = text.split('\n');
            const result = [];
            let inList = false;
            let currentParagraph = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Headers
                if (line.startsWith('### ')) {
                    if (currentParagraph) {
                        result.push(`<p>${currentParagraph}</p>`);
                        currentParagraph = '';
                    }
                    if (inList) { result.push('</ul>'); inList = false; }
                    result.push(`<h3>${line.substring(4)}</h3>`);
                } else if (line.startsWith('## ')) {
                    if (currentParagraph) {
                        result.push(`<p>${currentParagraph}</p>`);
                        currentParagraph = '';
                    }
                    if (inList) { result.push('</ul>'); inList = false; }
                    result.push(`<h2>${line.substring(3)}</h2>`);
                } else if (line.startsWith('# ')) {
                    if (currentParagraph) {
                        result.push(`<p>${currentParagraph}</p>`);
                        currentParagraph = '';
                    }
                    if (inList) { result.push('</ul>'); inList = false; }
                    result.push(`<h1>${line.substring(2)}</h1>`);
                }
                // List items (including standalone numbers like "1.", "2.", etc.)
                else if (line.startsWith('- ') || /^\d+\.\s*$/.test(line) || /^\d+\.\s+/.test(line)) {
                    if (currentParagraph) {
                        result.push(`<p>${currentParagraph}</p>`);
                        currentParagraph = '';
                    }
                    if (!inList) {
                        result.push('<ul>');
                        inList = true;
                    }
                    
                    let content;
                    if (line.startsWith('- ')) {
                        content = line.substring(2);
                    } else if (/^\d+\.\s*$/.test(line)) {
                        // Just a number like "1." or "2." - look ahead for content
                        content = line;
                        // Check if next line has content that should be part of this list item
                        if (i + 1 < lines.length && lines[i + 1].trim() && !lines[i + 1].trim().match(/^(#{1,3}|[-\d])/)) {
                            i++; // consume next line
                            content = line + ' ' + lines[i].trim();
                        }
                    } else {
                        content = line.replace(/^\d+\.\s+/, match => match);
                    }
                    result.push(`<li>${content}</li>`);
                }
                // Empty line - paragraph break
                else if (line === '') {
                    if (currentParagraph) {
                        result.push(`<p>${currentParagraph}</p>`);
                        currentParagraph = '';
                    }
                    if (inList) { result.push('</ul>'); inList = false; }
                }
                // Regular text
                else {
                    if (inList) { result.push('</ul>'); inList = false; }
                    if (currentParagraph) {
                        currentParagraph += ' ' + line;
                    } else {
                        currentParagraph = line;
                    }
                }
            }
            
            // Close any remaining elements
            if (currentParagraph) {
                result.push(`<p>${currentParagraph}</p>`);
            }
            if (inList) {
                result.push('</ul>');
            }
            
            // Apply bold formatting
            return result.join('').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        }

        function App() {
            const [data, setData] = useState(null);
            const [error, setError] = useState(null);
            const [gistUrl, setGistUrl] = useState('');
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const gist = params.get('gist');
                if (gist) {
                    setGistUrl(gist);
                    loadFromGist(gist);
                }
            }, []);

            const loadFromGist = async (url) => {
                setLoading(true);
                setError(null);
                
                try {
                    let fetchUrl = url;
                    
                    // Convert GitHub gist URL to raw URL if needed
                    if (url.includes('github.com') && url.includes('/gist/')) {
                        const gistId = url.split('/').pop().split('#')[0];
                        fetchUrl = `https://gist.githubusercontent.com/oaustegard/${gistId}/raw`;
                    }
                    
                    const response = await fetch(fetchUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    const parsed = JSON.parse(text);
                    setData(parsed);
                } catch (err) {
                    setError(`Error loading gist: ${err.message}`);
                } finally {
                    setLoading(false);
                }
            };

            const handleLoad = () => {
                if (gistUrl.trim()) {
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.set('gist', gistUrl.trim());
                    window.history.pushState({}, '', newUrl);
                    loadFromGist(gistUrl.trim());
                }
            };

            const toggleCollapsible = (e) => {
                const header = e.currentTarget;
                const collapsible = header.parentElement;
                collapsible.classList.toggle('expanded');
            };

            const renderContent = (content) => {
                if (!content || !Array.isArray(content)) return null;

                // Group searches and results together
                const processedContent = [];
                const searchGroups = [];
                let currentSearchGroup = null;

                // First pass: group search-related items
                content.forEach((item, index) => {
                    if (item.type === 'thinking') {
                        processedContent.push(item);
                    } else if (item.type === 'server_tool_use' && item.name === 'web_search') {
                        currentSearchGroup = { searches: [item], results: [] };
                        searchGroups.push(currentSearchGroup);
                    } else if (item.type === 'web_search_tool_result' && currentSearchGroup) {
                        currentSearchGroup.results.push(item);
                    } else {
                        if (currentSearchGroup) {
                            processedContent.push({ type: 'search_group', groups: [...searchGroups] });
                            searchGroups.length = 0;
                            currentSearchGroup = null;
                        }
                        processedContent.push(item);
                    }
                });

                // Don't forget remaining search groups
                if (searchGroups.length > 0) {
                    processedContent.push({ type: 'search_group', groups: [...searchGroups] });
                }

                let citationCounter = 1;

                return processedContent.map((item, index) => {
                    if (item.type === 'thinking') {
                        return html`
                            <div key=${index} class="collapsible">
                                <div class="collapsible-header" onClick=${toggleCollapsible}>
                                    🤔 Thinking Process
                                </div>
                                <div class="collapsible-content">
                                    <div class="thinking-content">${item.thinking}</div>
                                </div>
                            </div>
                        `;
                    }

                    if (item.type === 'search_group') {
                        const totalSearches = item.groups.reduce((acc, group) => acc + group.searches.length, 0);
                        return html`
                            <div key=${index} class="collapsible">
                                <div class="collapsible-header" onClick=${toggleCollapsible}>
                                    🔍 Web Research (${totalSearches} searches)
                                </div>
                                <div class="collapsible-content">
                                    ${item.groups.map((group, groupIdx) => html`
                                        <div key=${groupIdx} class="search-section">
                                            ${group.searches.map((search, searchIdx) => html`
                                                <div key=${searchIdx} class="search-query">
                                                    🔍 Query: "${search.input.query}"
                                                </div>
                                            `)}
                                            ${group.results.map((result, resultIdx) => {
                                                const results = result.content?.filter(c => c.type === 'web_search_result') || [];
                                                return html`
                                                    <div key=${resultIdx}>
                                                        <div style="margin: 10px 0; font-weight: 500;">📋 Results (${results.length}):</div>
                                                        ${results.map((res, resIdx) => html`
                                                            <div key=${resIdx} class="search-result">
                                                                <h4><a href=${res.url} target="_blank">${res.title}</a></h4>
                                                                <div class="search-url">${res.url}</div>
                                                                ${res.page_age && html`<div style="font-size: 12px; color: #666;">Page age: ${res.page_age}</div>`}
                                                            </div>
                                                        `)}
                                                    </div>
                                                `;
                                            })}
                                        </div>
                                    `)}
                                </div>
                            </div>
                        `;
                    }

                    if (item.type === 'text') {
                        // Check if this text item has citations
                        if (item.citations && item.citations.length > 0) {
                            const citationLinks = item.citations.map(citation => {
                                const citationNum = citationCounter++;
                                const safeTitle = `${citation.title}: ${citation.cited_text}`.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<a href="${citation.url}" class="citation" target="_blank" title="${safeTitle}">${citationNum}</a>`;
                            });

                            let htmlContent = markdownToHtml(item.text);
                            
                            // Insert citations at the very end of the last closing tag
                            const lastTagRegex = /(<\/(?:p|li|h[1-6])>)(?!.*<\/(?:p|li|h[1-6])>)/;
                            if (lastTagRegex.test(htmlContent)) {
                                htmlContent = htmlContent.replace(lastTagRegex, citationLinks.join('') + '$1');
                            } else {
                                htmlContent = htmlContent + citationLinks.join('');
                            }
                            
                            return html`
                                <div key=${index} class="content-text" dangerouslySetInnerHTML=${{ __html: htmlContent }}></div>
                            `;
                        } else {
                            const htmlContent = markdownToHtml(item.text);
                            return html`
                                <div key=${index} class="content-text" dangerouslySetInnerHTML=${{ __html: htmlContent }}></div>
                            `;
                        }
                    }

                    return null;
                }).filter(Boolean);
            };

            return html`
                <div class="container">
                    <h1>Claude API Response Viewer</h1>
                    
                    <div class="input-section">
                        <h2>Load from GitHub Gist</h2>
                        <input 
                            type="text" 
                            class="gist-input"
                            placeholder="Paste GitHub Gist URL containing Claude API JSON response"
                            value=${gistUrl}
                            onInput=${(e) => setGistUrl(e.target.value)}
                        />
                        <button class="load-btn" onClick=${handleLoad} disabled=${loading}>
                            ${loading ? 'Loading...' : 'Load Response'}
                        </button>
                        
                        ${!data && !error && html`
                            <div class="instructions">
                                <strong>Instructions:</strong> Create a GitHub Gist containing only the JSON output 
                                from an Anthropic API response, then paste the gist URL above and click "Load Response".
                            </div>
                        `}
                    </div>

                    ${error && html`<div class="error">${error}</div>`}
                    
                    ${data && html`
                        <div class="content-section">
                            ${renderContent(data.content)}
                        </div>
                    `}
                </div>
            `;
        }

        render(html`<${App} />`, document.getElementById('app'));
    </script>
</body>
</html>
