<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spectral Tree</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        body { margin: 0; background-color: #000; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.6);
            padding: 20px; border-radius: 12px; border: 1px solid #444; width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto; z-index: 10;
            backdrop-filter: blur(5px);
        }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #ff3e3e; }
        h1 { font-size: 1.2rem; margin: 0 0 15px 0; color: #fff; font-weight: 300; }
        .stats { font-size: 0.7rem; color: #666; margin-top: 10px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; font-style: italic; color: gold; z-index: 20; pointer-events: none;}
    </style>
</head>
<body>

<div id="ui">
    <h1>Spectral Tree</h1>
    
    <div class="control-group">
        <label id="label-n">Branches: 300</label>
        <input type="range" id="nodes" min="50" max="500" value="300" step="10">
    </div>

    <div class="control-group">
        <label id="label-wiggle">Curvature: 0.08</label>
        <input type="range" id="wiggle" min="0" max="20" value="8">
    </div>

    <div class="control-group">
        <label id="label-speed">Rotation Speed: Medium</label>
        <input type="range" id="speed" min="0" max="10" value="3">
    </div>

    <button id="regenerate" style="width:100%; padding: 8px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">Regenerate Tree</button>

    <div class="stats">
        Visualizing eigenvalue trajectories of $M(t) = (1-t)A + tB$.
    </div>
</div>

<div id="loading">Solving Eigenvalues...</div>
<canvas id="treeCanvas"></canvas>

<script>
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    
    // Configuration
    let N = 300;
    const steps = 60;
    let couplingStrength = 0.08;
    let treeWidthFactor = 0.9;
    let rotationSpeed = 0.005;

    // Animation State
    let animationFrameId;
    let rotationAngle = 0;

    // Data Storage
    let activeTrajectories = null;
    let activeHeights = null;
    let branchAngles = null; // Random angle for each branch (0 to 2PI)

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- CORE MATH ---
    async function computeTreeData() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        loading.style.display = 'block';
        
        // Small delay to allow UI to update
        await new Promise(r => setTimeout(r, 20));

        const trajectories = []; 
        const heights = [];
        const A_diag = [];
        const B_diag = [];
        branchAngles = new Float32Array(N);

        for (let i = 0; i < N; i++) {
            const h = (i / N);
            heights.push(h);
            branchAngles[i] = Math.random() * Math.PI * 2;

            // Power function for conical shape
            const maxWidth = Math.pow(1.1 - h, 1.5) * treeWidthFactor;
            // Force spread to simulate volume
            const side = Math.random() > 0.5 ? 1 : -1;

            // Matrix A (Trunk cluster)
            A_diag.push(math.complex(Math.random() * 0.04 - 0.02, h));
            // Matrix B (Branch tips)
            B_diag.push(math.complex(side * (Math.random() * 0.4 + 0.6) * maxWidth, h + (Math.random() * 0.02 - 0.01)));
        }

        // Generate Block Coupling (Pairwise)
        const C_blocks = [];
        for (let i = 0; i < N; i += 2) {
             const blk = [
                 [math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength),
                  math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength)],
                 [math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength),
                  math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength)]
             ];
             C_blocks.push(blk);
        }

        // Solve Eigenvalues
        for (let s = 0; s <= steps; s++) {
            const t = s / steps;
            let currentStepEvals = [];

            for (let i = 0; i < N; i += 2) {
                if (i + 1 < N) {
                    const d1 = math.add(math.multiply(A_diag[i], 1 - t), math.multiply(B_diag[i], t));
                    const d2 = math.add(math.multiply(A_diag[i+1], 1 - t), math.multiply(B_diag[i+1], t));
                    const cBlk = C_blocks[Math.floor(i/2)];

                    const m00 = math.add(d1, cBlk[0][0]);
                    const m01 = cBlk[0][1];
                    const m10 = cBlk[1][0];
                    const m11 = math.add(d2, cBlk[1][1]);

                    const M_small = [[m00, m01], [m10, m11]];
                    const res = math.eigs(M_small);
                    const vals = res.values.toArray ? res.values.toArray() : res.values;
                    currentStepEvals.push(vals[0], vals[1]);
                } else {
                    const d = math.add(math.multiply(A_diag[i], 1 - t), math.multiply(B_diag[i], t));
                    currentStepEvals.push(d);
                }
            }
            
            // Sort by imaginary part for continuity
            currentStepEvals.sort((a, b) => {
                const imA = typeof a === 'number' ? 0 : a.im;
                const imB = typeof b === 'number' ? 0 : b.im;
                return imA - imB;
            });
            trajectories.push(currentStepEvals);
        }

        activeTrajectories = trajectories;
        activeHeights = heights;
        loading.style.display = 'none';
        animate();
    }

    // --- ANIMATION LOOP ---
    function animate() {
        if (!activeTrajectories) return;

        // 1. Clear Screen with slight fade? No, standard clear for sharp movement
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Additive blending for neon effect
        ctx.globalCompositeOperation = 'lighter';

        const centerX = canvas.width / 2;
        const bottomY = canvas.height * 0.9;
        const scale = canvas.height * 0.75;
        const widthScale = canvas.width * 0.45;

        // 2. Draw Full Tree
        for (let j = 0; j < N; j++) {
            // Color mapping based on height
            const hue = (activeHeights[j] * 280); 
            ctx.strokeStyle = `hsla(${hue}, 90%, 60%, 0.6)`;
            ctx.lineWidth = 0.6;
            ctx.beginPath();

            const phi = branchAngles[j]; // The static random angle of this branch
            const cosRot = Math.cos(rotationAngle + phi);

            // Draw entire path for this branch
            for (let s = 0; s <= steps; s++) {
                const ev = activeTrajectories[s][j];
                const re = typeof ev === 'number' ? ev : ev.re;
                const im = typeof ev === 'number' ? 0 : ev.im;

                // 3D Rotation Projection
                // We treat 're' as the radial distance from the central axis.
                // We project it onto the 2D screen X axis using the rotation angle.
                const x = centerX + (re * cosRot) * widthScale;
                const y = bottomY - im * scale;

                if (s === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 3. Draw Tip Star
            // Only draw if it's "facing" us? No, draw all.
            const endNode = activeTrajectories[steps][j];
            const reEnd = typeof endNode === 'number' ? endNode : endNode.re;
            const imEnd = typeof endNode === 'number' ? 0 : endNode.im;
            const xEnd = centerX + (reEnd * cosRot) * widthScale;
            const yEnd = bottomY - imEnd * scale;

            // Simple depth cue: brightness or size based on Z?
            // Z approx = re * sin(rotationAngle + phi)
            // But 're' can be negative, so it's complicated.
            // Let's just keep it simple.

            drawStar(xEnd, yEnd, 1.2, `hsla(${hue}, 100%, 80%, 0.8)`);
        }
        
        // Increment rotation
        rotationAngle += rotationSpeed;

        // Signature
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '12px sans-serif';
        ctx.fillText('Spectral Tree', canvas.width - 100, canvas.height - 20);

        animationFrameId = requestAnimationFrame(animate);
    }

    function drawStar(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // UI Event Listeners
    document.getElementById('nodes').oninput = (e) => {
        N = parseInt(e.target.value);
        document.getElementById('label-n').innerText = `Branches: ${N}`;
    };
    document.getElementById('wiggle').oninput = (e) => {
        couplingStrength = e.target.value / 100;
        document.getElementById('label-wiggle').innerText = `Curvature: ${couplingStrength.toFixed(2)}`;
    };
    document.getElementById('speed').oninput = (e) => {
        const val = parseInt(e.target.value);
        rotationSpeed = val * 0.002; // Map 0-10 to 0.0 - 0.02
        document.getElementById('label-speed').innerText = `Rotation Speed: ${val}`;
    };
    document.getElementById('regenerate').onclick = computeTreeData;

    // Initial run
    computeTreeData();

</script>
</body>
</html>
