<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spectral Tree</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        body { margin: 0; background-color: #000; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { display: block; cursor: crosshair; }
        #ui {
            position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.6);
            padding: 20px; border-radius: 12px; border: 1px solid #444; width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto; z-index: 10;
            backdrop-filter: blur(5px);
        }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #ff3e3e; }
        h1 { font-size: 1.2rem; margin: 0 0 15px 0; color: #fff; font-weight: 300; }
        .stats { font-size: 0.7rem; color: #666; margin-top: 10px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; font-style: italic; color: gold; z-index: 20; pointer-events: none;}
        button { width: 100%; padding: 8px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 4px; margin-bottom: 8px; }
        button:hover { background: #444; }

        /* Info panel for clicked branch */
        #info-panel {
            position: absolute; bottom: 20px; right: 20px; background: rgba(0, 0, 0, 0.85);
            padding: 20px; border-radius: 12px; border: 1px solid #555; max-width: 350px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto; z-index: 10;
            backdrop-filter: blur(5px); display: none;
        }
        #info-panel h2 { margin: 0 0 10px 0; font-size: 1rem; color: gold; font-weight: 400; }
        #info-panel .close-btn { position: absolute; top: 10px; right: 12px; cursor: pointer; color: #888; font-size: 1.2rem; }
        #info-panel .close-btn:hover { color: #fff; }
        #info-panel p { margin: 8px 0; font-size: 0.85rem; line-height: 1.5; }
        #info-panel .math { font-family: 'Courier New', monospace; color: #8f8; background: rgba(0,100,0,0.2); padding: 2px 6px; border-radius: 3px; }
        #info-panel .eigenvalue { color: #ff8; font-weight: bold; }
        #info-panel .matrix-info { color: #aaf; }
        #info-panel hr { border-color: #444; margin: 10px 0; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Spectral Tree</h1>

    <div class="control-group">
        <label id="label-n">Branches: 400</label>
        <input type="range" id="nodes" min="100" max="600" value="400" step="10">
    </div>

    <div class="control-group">
        <label id="label-wiggle">Curvature: 0.08</label>
        <input type="range" id="wiggle" min="0" max="20" value="8">
    </div>

    <div class="control-group">
        <label id="label-speed">Rotation Speed: Medium</label>
        <input type="range" id="speed" min="0" max="10" value="3">
    </div>

    <button id="regenerate">Regenerate Tree</button>

    <div class="stats">
        Visualizing eigenvalue trajectories of M(t) = (1-t)A + tB.<br>
        <span style="color: #888;">Click on a star to see the math!<br>
        Drag to rotate the tree in 3D.</span>
    </div>
</div>

<div id="info-panel">
    <span class="close-btn" onclick="closeInfoPanel()">&times;</span>
    <h2>Branch Details</h2>
    <div id="info-content"></div>
</div>

<div id="loading">Solving Eigenvalues...</div>
<canvas id="treeCanvas"></canvas>

<script>
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    const infoPanel = document.getElementById('info-panel');
    const infoContent = document.getElementById('info-content');

    // Configuration
    let N = 400;
    const steps = 80;
    let couplingStrength = 0.08;
    let treeWidthFactor = 0.9;
    let rotationSpeed = 0.005;

    // Animation State
    let animationFrameId;
    let rotationAngle = 0;
    let manualRotationX = 0; // Manual rotation around X-axis (up/down)
    let manualRotationY = 0; // Manual rotation around Y-axis (left/right)

    // Mouse drag state
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Data Storage
    let activeTrajectories = null;
    let activeHeights = null;
    let branchAngles = null;
    let branchHues = null; // Store initial hue for each branch
    let A_diag_stored = null;
    let B_diag_stored = null;
    let selectedBranch = null;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Load parameters from URL
    function loadURLParams() {
        const params = new URLSearchParams(window.location.search);
        if (params.has('n')) N = parseInt(params.get('n'));
        if (params.has('wiggle')) couplingStrength = parseFloat(params.get('wiggle'));
        if (params.has('speed')) rotationSpeed = parseFloat(params.get('speed'));

        // Update UI controls
        document.getElementById('nodes').value = N;
        document.getElementById('label-n').innerText = `Branches: ${N}`;
        document.getElementById('wiggle').value = Math.round(couplingStrength * 100);
        document.getElementById('label-wiggle').innerText = `Curvature: ${couplingStrength.toFixed(2)}`;

        const speedVal = Math.round(rotationSpeed / 0.002);
        document.getElementById('speed').value = speedVal;
        const labels = ['Stopped', 'Very Slow', 'Slow', 'Medium', 'Medium', 'Medium-Fast', 'Fast', 'Fast', 'Very Fast', 'Ultra Fast', 'Maximum'];
        document.getElementById('label-speed').innerText = `Rotation Speed: ${labels[speedVal]}`;
    }

    // Update URL with current parameters
    function updateURL() {
        const params = new URLSearchParams();
        params.set('n', N);
        params.set('wiggle', couplingStrength.toFixed(2));
        params.set('speed', rotationSpeed.toFixed(4));
        const newURL = window.location.pathname + '?' + params.toString();
        window.history.replaceState({}, '', newURL);
    }

    // Color mapping: X position -> full spectral rainbow
    // Left (negative X) = magenta/red, Center = blue, Right (positive X) = green/yellow
    function getHueForX(x, maxWidth) {
        // Normalize x from [-maxWidth, maxWidth] to [0, 1]
        const normalized = (x / maxWidth + 1) / 2; // 0 = far left, 1 = far right
        // Map to full rainbow: 300 (magenta) -> 240 (blue) -> 120 (green) -> 60 (yellow)
        // Reversed direction: left=magenta(300), right=yellow/green(60-120)
        const hue = 300 - normalized * 240;
        return hue < 0 ? hue + 360 : hue;
    }

    // --- CORE MATH ---
    async function computeTreeData() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        loading.style.display = 'block';
        selectedBranch = null;
        closeInfoPanel();

        await new Promise(r => setTimeout(r, 20));

        const trajectories = [];
        const heights = [];
        const A_diag = [];
        const B_diag = [];
        branchAngles = new Float32Array(N);
        branchHues = new Float32Array(N); // Store initial hue for each branch

        for (let i = 0; i < N; i++) {
            const h = (i / N);
            heights.push(h);
            branchAngles[i] = Math.random() * Math.PI * 2;

            const maxWidth = Math.pow(1.1 - h, 1.5) * treeWidthFactor;
            const side = Math.random() > 0.5 ? 1 : -1;

            // Matrix A (Trunk cluster)
            A_diag.push(math.complex(Math.random() * 0.04 - 0.02, h));
            // Matrix B (Branch tips)
            const bDiag = math.complex(side * (Math.random() * 0.4 + 0.6) * maxWidth, h + (Math.random() * 0.02 - 0.01));
            B_diag.push(bDiag);

            // Calculate initial hue based on the final position without rotation
            const initialX = bDiag.re;
            branchHues[i] = getHueForX(initialX, maxWidth);
        }

        // Store for info panel
        A_diag_stored = A_diag.slice();
        B_diag_stored = B_diag.slice();

        // Generate Block Coupling (Pairwise)
        const C_blocks = [];
        for (let i = 0; i < N; i += 2) {
             const blk = [
                 [math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength),
                  math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength)],
                 [math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength),
                  math.complex((Math.random()-0.5)*couplingStrength, (Math.random()-0.5)*couplingStrength)]
             ];
             C_blocks.push(blk);
        }

        // Solve Eigenvalues
        for (let s = 0; s <= steps; s++) {
            const t = s / steps;
            let currentStepEvals = [];

            for (let i = 0; i < N; i += 2) {
                if (i + 1 < N) {
                    const d1 = math.add(math.multiply(A_diag[i], 1 - t), math.multiply(B_diag[i], t));
                    const d2 = math.add(math.multiply(A_diag[i+1], 1 - t), math.multiply(B_diag[i+1], t));
                    const cBlk = C_blocks[Math.floor(i/2)];

                    const m00 = math.add(d1, cBlk[0][0]);
                    const m01 = cBlk[0][1];
                    const m10 = cBlk[1][0];
                    const m11 = math.add(d2, cBlk[1][1]);

                    const M_small = [[m00, m01], [m10, m11]];
                    const res = math.eigs(M_small);
                    const vals = res.values.toArray ? res.values.toArray() : res.values;
                    currentStepEvals.push(vals[0], vals[1]);
                } else {
                    const d = math.add(math.multiply(A_diag[i], 1 - t), math.multiply(B_diag[i], t));
                    currentStepEvals.push(d);
                }
            }

            // Sort by imaginary part for continuity
            currentStepEvals.sort((a, b) => {
                const imA = typeof a === 'number' ? 0 : a.im;
                const imB = typeof b === 'number' ? 0 : b.im;
                return imA - imB;
            });
            trajectories.push(currentStepEvals);
        }

        activeTrajectories = trajectories;
        activeHeights = heights;
        loading.style.display = 'none';
        updateURL(); // Update URL with current parameters
        animate();
    }

    // --- ANIMATION LOOP ---
    function animate() {
        if (!activeTrajectories) return;

        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.globalCompositeOperation = 'lighter';

        const centerX = canvas.width / 2;
        const bottomY = canvas.height * 0.9;
        const scale = canvas.height * 0.75;
        const widthScale = canvas.width * 0.45;
        const maxWidth = treeWidthFactor;

        // Draw all branches
        for (let j = 0; j < N; j++) {
            const phi = branchAngles[j];
            const totalRotationAngle = rotationAngle + phi + manualRotationY;
            const cosRot = Math.cos(totalRotationAngle);
            const sinRot = Math.sin(totalRotationAngle);

            // Use stored hue that rotates with the branch
            const hue = branchHues[j];

            // Determine if this branch is selected
            const isSelected = (selectedBranch === j);

            if (isSelected) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.lineWidth = 2.5;
            } else {
                ctx.strokeStyle = `hsla(${hue}, 90%, 60%, 0.6)`;
                ctx.lineWidth = 0.6;
            }

            ctx.beginPath();

            for (let s = 0; s <= steps; s++) {
                const ev = activeTrajectories[s][j];
                const re = typeof ev === 'number' ? ev : ev.re;
                const im = typeof ev === 'number' ? 0 : ev.im;

                // Apply rotation around Y-axis (horizontal rotation)
                const rotatedX = re * cosRot;
                const rotatedZ = re * sinRot; // Depth

                // Apply manual rotation around X-axis (vertical tilt)
                const cosX = Math.cos(manualRotationX);
                const sinX = Math.sin(manualRotationX);
                const rotatedY = im * cosX - rotatedZ * sinX;
                const finalZ = im * sinX + rotatedZ * cosX;

                // Perspective projection (simple)
                const perspective = 1 / (1 + finalZ * 0.1);
                const x = centerX + rotatedX * widthScale * perspective;
                const y = bottomY - rotatedY * scale * perspective;

                if (s === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw tip star
            const endNode = activeTrajectories[steps][j];
            const reEnd = typeof endNode === 'number' ? endNode : endNode.re;
            const imEnd = typeof endNode === 'number' ? 0 : endNode.im;

            // Apply same rotations to tip
            const rotatedXEnd = reEnd * cosRot;
            const rotatedZEnd = reEnd * sinRot;
            const cosX = Math.cos(manualRotationX);
            const sinX = Math.sin(manualRotationX);
            const rotatedYEnd = imEnd * cosX - rotatedZEnd * sinX;
            const finalZEnd = imEnd * sinX + rotatedZEnd * cosX;
            const perspectiveEnd = 1 / (1 + finalZEnd * 0.1);

            const xEnd = centerX + rotatedXEnd * widthScale * perspectiveEnd;
            const yEnd = bottomY - rotatedYEnd * scale * perspectiveEnd;

            if (isSelected) {
                drawStar(xEnd, yEnd, 4, 'rgba(255, 255, 255, 1)');
            } else {
                drawStar(xEnd, yEnd, 1.5, `hsla(${hue}, 100%, 80%, 0.9)`);
            }
        }

        rotationAngle += rotationSpeed;

        // Signature (clickable)
        ctx.globalCompositeOperation = 'source-over';
        const sigX = canvas.width - 250;
        const sigY = canvas.height - 20;

        // Check if mouse is hovering over signature
        const mouseX = lastMouseX || 0;
        const mouseY = lastMouseY || 0;
        const rect = canvas.getBoundingClientRect();
        const canvasMouseX = mouseX - rect.left;
        const canvasMouseY = mouseY - rect.top;
        const isHoveringSignature = canvasMouseX >= sigX && canvasMouseX <= canvas.width - 10 &&
                                   canvasMouseY >= sigY - 15 && canvasMouseY <= sigY + 5;

        if (isHoveringSignature && !isDragging) {
            ctx.fillStyle = 'rgba(100, 150, 255, 0.9)';
            ctx.font = '11px sans-serif';
            canvas.style.cursor = 'pointer';
        } else {
            ctx.fillStyle = 'rgba(150, 150, 150, 0.7)';
            ctx.font = '11px sans-serif';
            if (!isDragging) canvas.style.cursor = 'crosshair';
        }

        ctx.fillText('Original concept by Simone Conradi, 2025', sigX, sigY);

        // Underline when hovering
        if (isHoveringSignature && !isDragging) {
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(sigX, sigY + 2);
            ctx.lineTo(canvas.width - 10, sigY + 2);
            ctx.stroke();
        }

        animationFrameId = requestAnimationFrame(animate);
    }

    function drawStar(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- INTERACTIVITY: Click and Drag ---
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
    canvas.addEventListener('click', handleCanvasClick);

    function handleMouseDown(event) {
        isDragging = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        canvas.style.cursor = 'grabbing';
    }

    function handleMouseMove(event) {
        if (isDragging) {
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;

            // Horizontal drag rotates around Y-axis (left/right spin)
            manualRotationY += deltaX * 0.01;

            // Vertical drag rotates around X-axis (up/down tilt)
            manualRotationX += deltaY * 0.01;

            // Clamp X rotation to prevent flipping
            manualRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, manualRotationX));
        }

        // Always update last mouse position for signature hover detection
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function handleMouseUp() {
        isDragging = false;
        canvas.style.cursor = 'crosshair';
    }

    function handleCanvasClick(event) {
        if (!activeTrajectories) return;

        // Don't register clicks during drag
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        // Check if clicking on attribution link
        const sigX = canvas.width - 250;
        const sigY = canvas.height - 20;
        if (clickX >= sigX && clickX <= canvas.width - 10 && clickY >= sigY - 15 && clickY <= sigY + 5) {
            window.open('https://bsky.app/profile/sconradi.bsky.social/post/3mave3hi6t227', '_blank');
            return;
        }

        const centerX = canvas.width / 2;
        const bottomY = canvas.height * 0.9;
        const scale = canvas.height * 0.75;
        const widthScale = canvas.width * 0.45;

        let nearestBranch = null;
        let nearestDist = Infinity;
        const hitRadius = 20;

        for (let j = 0; j < N; j++) {
            const phi = branchAngles[j];
            const totalRotationAngle = rotationAngle + phi + manualRotationY;
            const cosRot = Math.cos(totalRotationAngle);
            const sinRot = Math.sin(totalRotationAngle);

            const ev = activeTrajectories[steps][j];
            const re = typeof ev === 'number' ? ev : ev.re;
            const im = typeof ev === 'number' ? 0 : ev.im;

            // Apply same rotation calculations
            const rotatedX = re * cosRot;
            const rotatedZ = re * sinRot;
            const cosX = Math.cos(manualRotationX);
            const sinX = Math.sin(manualRotationX);
            const rotatedY = im * cosX - rotatedZ * sinX;
            const finalZ = im * sinX + rotatedZ * cosX;
            const perspective = 1 / (1 + finalZ * 0.1);

            const x = centerX + rotatedX * widthScale * perspective;
            const y = bottomY - rotatedY * scale * perspective;

            const dist = Math.sqrt((clickX - x) ** 2 + (clickY - y) ** 2);
            if (dist < hitRadius && dist < nearestDist) {
                nearestDist = dist;
                nearestBranch = j;
            }
        }

        if (nearestBranch !== null) {
            selectedBranch = nearestBranch;
            showBranchInfo(nearestBranch);
        } else {
            selectedBranch = null;
            closeInfoPanel();
        }
    }

    function showBranchInfo(branchIndex) {
        const aEv = A_diag_stored[branchIndex];
        const bEv = B_diag_stored[branchIndex];
        const heightNorm = activeHeights[branchIndex];
        const side = bEv.re > 0 ? 'right' : 'left';

        const formatComplex = (c) => {
            const re = c.re.toFixed(4);
            const im = c.im.toFixed(4);
            const sign = c.im >= 0 ? '+' : '';
            return `${re} ${sign} ${im}i`;
        };

        infoContent.innerHTML = `
            <p><strong>Branch #${branchIndex + 1}</strong> (${side} side)</p>
            <p>Height: ${(heightNorm * 100).toFixed(1)}% up the tree</p>
            <hr>
            <p><strong>Matrix Interpolation:</strong></p>
            <p class="math">M(t) = (1-t)A + tB</p>
            <p>As t goes from 0→1, eigenvalues trace curved paths from trunk to tips.</p>
            <hr>
            <p><strong>Eigenvalue at t=0 (Matrix A):</strong></p>
            <p class="eigenvalue matrix-info">${formatComplex(aEv)}</p>
            <p style="color: #888; font-size: 0.75rem;">Near trunk center (small real part)</p>
            <hr>
            <p><strong>Eigenvalue at t=1 (Matrix B):</strong></p>
            <p class="eigenvalue">${formatComplex(bEv)}</p>
            <p style="color: #888; font-size: 0.75rem;">Branch tip (larger |real part| = wider)</p>
            <hr>
            <p><strong>Gershgorin's Theorem:</strong></p>
            <p style="font-size: 0.8rem; color: #aaa;">
                Each eigenvalue lies within a disc centered at a diagonal entry.
                By designing diagonal entries to form a tree shape, the eigenvalue
                trajectories create this spectral Christmas tree!
            </p>
            <hr>
            <p><strong>3D Effect:</strong></p>
            <p style="font-size: 0.8rem; color: #aaa;">
                Each branch has a random angle φ. The rotation projects
                the real part as: x·cos(θ + φ), creating the illusion
                of a rotating 3D cone.
            </p>
        `;

        infoPanel.style.display = 'block';
    }

    function closeInfoPanel() {
        infoPanel.style.display = 'none';
        selectedBranch = null;
    }

    // UI Event Listeners
    document.getElementById('nodes').oninput = (e) => {
        N = parseInt(e.target.value);
        document.getElementById('label-n').innerText = `Branches: ${N}`;
        updateURL();
    };
    document.getElementById('wiggle').oninput = (e) => {
        couplingStrength = e.target.value / 100;
        document.getElementById('label-wiggle').innerText = `Curvature: ${couplingStrength.toFixed(2)}`;
        updateURL();
    };
    document.getElementById('speed').oninput = (e) => {
        const val = parseInt(e.target.value);
        rotationSpeed = val * 0.002;
        const labels = ['Stopped', 'Very Slow', 'Slow', 'Medium', 'Medium', 'Medium-Fast', 'Fast', 'Fast', 'Very Fast', 'Ultra Fast', 'Maximum'];
        document.getElementById('label-speed').innerText = `Rotation Speed: ${labels[val]}`;
        updateURL();
    };
    document.getElementById('regenerate').onclick = computeTreeData;

    // Load parameters from URL and start
    loadURLParams();
    computeTreeData();

</script>
</body>
</html>
