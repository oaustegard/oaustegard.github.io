<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emoji Collage Maker</title>
  <!-- Preact and Hooks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/preact/10.19.3/preact.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/preact/10.19.3/hooks.umd.js"></script>
  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    /* Emoji Grid Styling */
    .emoji-grid {
      display: grid;
      font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji";
      letter-spacing: 0;
      word-spacing: 0;
      gap: 1px; /* Reduced gap between emojis */
      transform-origin: top left;
    }
    /* Custom element <e> used for each emoji cell */
    e {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      width: 1em;
      height: 1em;
      padding: 0;
    }
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #ccc;
      transition: background-color 0.3s;
      margin-left: 8px;
    }
    /* Collage Container (no border) */
    .collage-container {
      overflow: visible;
      position: relative;
      margin-top: 1rem;
    }
    /* Controls Row (Download/Open + Zoom) */
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .zoom-button {
      padding: 4px 8px;
      background-color: #e2e8f0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .zoom-button:hover {
      background-color: #cbd5e1;
    }
    /* Processing Canvas */
    #processingCanvas {
      display: block;
      margin-top: 1rem;
      border: 1px solid #ccc;
      max-width: 100%;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="app"></div>

<script>
  const { h, render } = window.preact;
  const { useState, useEffect, useRef } = window.preactHooks;

  // Helper: Convert hex color to RGB array
  const hexToRgb = (hex) => {
    hex = hex.replace(/^#/, '');
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const num = parseInt(hex, 16);
    return [(num >> 16) & 255, (num >> 8) & 255, num & 255];
  };

  // Helper functions for LAB color conversion
  function rgbToXyz(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x, y, z];
  }

  function xyzToLab(x, y, z) {
    const refX = 0.95047, refY = 1.000, refZ = 1.08883;
    x /= refX; y /= refY; z /= refZ;
    x = x > 0.008856 ? Math.cbrt(x) : (7.787 * x) + (16 / 116);
    y = y > 0.008856 ? Math.cbrt(y) : (7.787 * y) + (16 / 116);
    z = z > 0.008856 ? Math.cbrt(z) : (7.787 * z) + (16 / 116);
    const L = (116 * y) - 16;
    const a = 500 * (x - y);
    const b_ = 200 * (y - z);
    return [L, a, b_];
  }

  function rgbToLab(r, g, b) {
    return xyzToLab(...rgbToXyz(r, g, b));
  }

  // Helper: Convert RGB to HSL
  function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) { 
      h = s = 0; 
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      if (max === r) {
        h = (g - b) / d + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / d + 2;
      } else {
        h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return { h, s, l };
  }

  /* Optimized Emoji Palette Generation:
     Only add skin tone variations for modifier-capable emojis.
     Also filter out the unwanted ðŸ”³ emoji.
  */
  const BASE_EMOJI_PALETTE = (() => {
    const ranges = [
      [0x1F300, 0x1F5FF],
      [0x1F600, 0x1F64F],
      [0x1F680, 0x1F6FF],
      [0x2600, 0x26FF],
      [0x2700, 0x27BF],
      [0x1F900, 0x1F9FF],
      [0x1FA70, 0x1FAFF],
    ];
    const skinTones = [
      '\u{1F3FB}', '\u{1F3FC}', '\u{1F3FD}', '\u{1F3FE}', '\u{1F3FF}'
    ];
    const emoji = new Set();
    for (const [start, end] of ranges) {
      for (let cp = start; cp <= end; cp++) {
        const base = String.fromCodePoint(cp);
        if (base === "ðŸ”³") continue;
        if (/^\p{Emoji}$/u.test(base)) {
          if (/\p{Emoji_Modifier_Base}/u.test(base)) {
            emoji.add(base);
            for (const tone of skinTones) {
              emoji.add(base + tone);
            }
          } else {
            emoji.add(base);
          }
        }
      }
    }
    return Array.from(emoji);
  })();

  /* 
    Modified extractEmojiColor:
    - Draws the emoji on a 100Ã—100 transparent canvas at 80px.
    - Computes the "coverage" as the fraction of pixels with alpha > 50.
    - If coverage is below 50% (indicating a sparse/mostly white emoji), we force effective opacity to 1.
    - Uses a quantized histogram (over pixels with alpha > 50) to pick a dominant color.
    Returns an object: { color: [r, g, b], opacity: effectiveOpacity }.
  */
  const extractEmojiColor = (emoji) => {
    return new Promise((resolve) => {
      const size = 100;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.clearRect(0, 0, size, size);
      ctx.font = '80px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      ctx.fillText(emoji, size / 2, size / 2);
      setTimeout(() => {
        try {
          const imageData = ctx.getImageData(0, 0, size, size);
          const data = imageData.data;
          let nonTransparentCount = 0;
          for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] > 50) nonTransparentCount++;
          }
          const coverage = nonTransparentCount / (size * size);
          // If coverage is low, force effective opacity to 1
          const effectiveOpacity = coverage < 0.5 ? 1 : coverage;

          const histogram = {};
          for (let i = 0; i < data.length; i += 4) {
            const alpha = data[i + 3];
            if (alpha < 50) continue;
            const r = data[i], g = data[i + 1], b = data[i + 2];
            const qr = Math.round(r / 16) * 16;
            const qg = Math.round(g / 16) * 16;
            const qb = Math.round(b / 16) * 16;
            const key = `${qr},${qg},${qb}`;
            histogram[key] = (histogram[key] || 0) + 1;
          }
          let dominantKey = null, maxCount = 0;
          for (const key in histogram) {
            if (histogram[key] > maxCount) {
              maxCount = histogram[key];
              dominantKey = key;
            }
          }
          const dominantColor = dominantKey ? dominantKey.split(',').map(Number) : [128, 128, 128];
          resolve({ color: dominantColor, opacity: effectiveOpacity });
        } catch (error) {
          console.error('Error analyzing emoji:', error);
          resolve({ color: [128, 128, 128], opacity: 1 });
        }
      }, 20);
    });
  };

  /* Cache or compute emoji colors (each as {color, opacity}) */
  const getCachedEmojiColors = async (updateProgress, updatePartial) => {
    const cached = localStorage.getItem('emojiColors');
    if (cached) {
      updateProgress(100);
      return JSON.parse(cached);
    } else {
      const colors = {};
      let partial = {};
      for (const [index, emoji] of BASE_EMOJI_PALETTE.entries()) {
        const result = await extractEmojiColor(emoji);
        colors[emoji] = result;
        partial[emoji] = result;
        if (updatePartial && index % 10 === 0) {
          updatePartial({ ...partial });
        }
        updateProgress(Math.floor(((index + 1) / BASE_EMOJI_PALETTE.length) * 100));
      }
      if (updatePartial) updatePartial(partial);
      localStorage.setItem('emojiColors', JSON.stringify(colors));
      return colors;
    }
  };

  /* Suggest a background color by averaging border pixels from the image */
  const suggestBackgroundColor = (imageData) => {
    const data = imageData.data;
    const { width, height } = imageData;
    let totalR = 0, totalG = 0, totalB = 0, count = 0;
    const borderWidth = Math.min(10, Math.floor(width * 0.05), Math.floor(height * 0.05));
    for (let y = 0; y < borderWidth; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        totalR += data[idx]; totalG += data[idx+1]; totalB += data[idx+2];
        count++;
      }
    }
    for (let y = height - borderWidth; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        totalR += data[idx]; totalG += data[idx+1]; totalB += data[idx+2];
        count++;
      }
    }
    for (let y = borderWidth; y < height - borderWidth; y++) {
      for (let x = 0; x < borderWidth; x++) {
        const idx = (y * width + x) * 4;
        totalR += data[idx]; totalG += data[idx+1]; totalB += data[idx+2];
        count++;
      }
      for (let x = width - borderWidth; x < width; x++) {
        const idx = (y * width + x) * 4;
        totalR += data[idx]; totalG += data[idx+1]; totalB += data[idx+2];
        count++;
      }
    }
    if (!count) return "#ffffff";
    const toHex = c => c.toString(16).padStart(2, '0');
    return `#${toHex(Math.round(totalR/count))}${toHex(Math.round(totalG/count))}${toHex(Math.round(totalB/count))}`;
  };

  const App = () => {
    const [imageData, setImageData] = useState(null);
    const [resolution, setResolution] = useState({ width: 32, height: 32 });
    const [emojiColors, setEmojiColors] = useState({});
    const [processedPalette, setProcessedPalette] = useState({});
    const [collage, setCollage] = useState([]);
    const [originalImage, setOriginalImage] = useState(null);
    const [readyToRender, setReadyToRender] = useState(false);
    const [paletteProgress, setPaletteProgress] = useState(0);
    const canvasRef = useRef(null);
    const [processing, setProcessing] = useState(false);
    const [zoomLevel, setZoomLevel] = useState(1);
    const [bgColor, setBgColor] = useState('#ffffff');

    useEffect(() => {
      const fetchEmojiColors = async () => {
        const colors = await getCachedEmojiColors(setPaletteProgress, setProcessedPalette);
        setEmojiColors(colors);
        setReadyToRender(true);
      };
      fetchEmojiColors();
    }, []);

    const calculateResolution = (w, h) => {
      const minDimension = 32;
      const aspectRatio = w / h;
      return w < h 
        ? { width: minDimension, height: Math.round(minDimension / aspectRatio) }
        : { width: Math.round(minDimension * aspectRatio), height: minDimension };
    };

    const updateResolution = (newW, newH, isWidth) => {
      if (!originalImage || !canvasRef.current) return;
      const aspect = originalImage.width / originalImage.height;
      let updatedW, updatedH;
      if (isWidth) {
        updatedW = newW;
        updatedH = Math.round(newW / aspect);
      } else {
        updatedH = newH;
        updatedW = Math.round(newH * aspect);
      }
      setResolution({ width: updatedW, height: updatedH });
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      canvas.width = updatedW;
      canvas.height = updatedH;
      ctx.drawImage(originalImage, 0, 0, updatedW, updatedH);
      setImageData(ctx.getImageData(0, 0, updatedW, updatedH));
      setCollage([]);
      setReadyToRender(true);
    };

    const handleImageUpload = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        const img = new Image();
        img.onload = () => {
          setOriginalImage(img);
          const newRes = calculateResolution(img.width, img.height);
          setResolution(newRes);
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          canvas.width = newRes.width;
          canvas.height = newRes.height;
          ctx.drawImage(img, 0, 0, newRes.width, newRes.height);
          const imgData = ctx.getImageData(0, 0, newRes.width, newRes.height);
          setImageData(imgData);
          const suggested = suggestBackgroundColor(imgData);
          setBgColor(suggested);
          setCollage([]);
          setReadyToRender(true);
        };
        img.onerror = (err) => console.error('Image load error:', err);
        img.src = evt.target.result;
      };
      reader.onerror = (err) => console.error('File read error:', err);
      reader.readAsDataURL(file);
    };

    /* 
      Generate the collage by matching each pixelâ€™s LAB value and HSL saturation
      to the effective (blended) color of each emoji.
      For each emoji, the effective color is computed by blending its dominant color 
      (from extraction) with the background color using its computed effective opacity.
      We then add a penalty term for saturation difference.
    */
    const generateCollage = () => {
      if (!imageData) { console.warn('No image data available.'); return; }
      if (paletteProgress < 100) { console.warn('Emoji palette not ready yet.'); return; }
      setProcessing(true);
      const data = imageData.data;
      const newCollage = [];
      const bgRgb = hexToRgb(bgColor);
      // Weight factor for saturation difference â€“ adjust as needed.
      const satLambda = 20;
      for (let y = 0; y < resolution.height; y++) {
        const row = [];
        for (let x = 0; x < resolution.width; x++) {
          const idx = (y * resolution.width + x) * 4;
          const pixelColor = [data[idx], data[idx+1], data[idx+2]];
          const pixelLab = rgbToLab(...pixelColor);
          const targetHsl = rgbToHsl(...pixelColor);
          let bestDiff = Infinity;
          let bestEmoji = BASE_EMOJI_PALETTE[0];
          for (const emoji of BASE_EMOJI_PALETTE) {
            const eData = emojiColors[emoji];
            if (!eData) continue;
            const raw = eData.color;
            const effOpacity = eData.opacity;
            const effectiveColor = [
              Math.round(raw[0] * effOpacity + bgRgb[0] * (1 - effOpacity)),
              Math.round(raw[1] * effOpacity + bgRgb[1] * (1 - effOpacity)),
              Math.round(raw[2] * effOpacity + bgRgb[2] * (1 - effOpacity))
            ];
            const effectiveLab = rgbToLab(...effectiveColor);
            const labDiff = Math.sqrt(
              Math.pow(effectiveLab[0] - pixelLab[0], 2) +
              Math.pow(effectiveLab[1] - pixelLab[1], 2) +
              Math.pow(effectiveLab[2] - pixelLab[2], 2)
            );
            const emojiHsl = rgbToHsl(...effectiveColor);
            const satDiff = Math.abs(emojiHsl.s - targetHsl.s);
            const totalDiff = labDiff + satLambda * satDiff;
            if (totalDiff < bestDiff) {
              bestDiff = totalDiff;
              bestEmoji = emoji;
            }
          }
          row.push(bestEmoji);
        }
        newCollage.push(row);
      }
      setCollage(newCollage);
      setProcessing(false);
    };

    const downloadPNG = () => {
      if (!collage.length) return;
      const tempCanvas = document.createElement('canvas');
      const scale = 20;
      tempCanvas.width = resolution.width * scale;
      tempCanvas.height = resolution.height * scale;
      const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      ctx.font = `${scale}px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"`;
      ctx.textBaseline = 'top';
      for (let y = 0; y < resolution.height; y++) {
        for (let x = 0; x < resolution.width; x++) {
          ctx.fillText(collage[y][x], x * scale, y * scale);
        }
      }
      tempCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'emoji_collage.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };

    const downloadSVG = () => {
      if (!collage.length) return;
      const emojiSize = 20;
      const svgW = resolution.width * emojiSize;
      const svgH = resolution.height * emojiSize;
      let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}">`;
      svgContent += `<rect width="100%" height="100%" fill="${bgColor}"/>`;
      for (let y = 0; y < resolution.height; y++) {
        for (let x = 0; x < resolution.width; x++) {
          svgContent += `<text x="${x * emojiSize}" y="${(y + 1) * emojiSize}" font-size="${emojiSize}" font-family="Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, Android Emoji">${collage[y][x]}</text>`;
        }
      }
      svgContent += '</svg>';
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'emoji_collage.svg';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };

    const openFullPage = () => {
      if (!collage.length) return;
      const baseFontSize = Math.max(8, Math.min(32, 800 / resolution.width));
      const effectiveFontSize = baseFontSize * zoomLevel;
      const htmlContent = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <title>Emoji Collage</title>
          <style>
            body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: ${bgColor}; }
            .emoji-grid { display: grid; grid-template-columns: repeat(${resolution.width}, 1em); gap: 1px; font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Android Emoji'; letter-spacing: 0; word-spacing: 0; font-size: ${effectiveFontSize}px; }
            e { display: inline-flex; align-items: center; justify-content: center; line-height: 1; width: 1em; height: 1em; padding: 0; }
          </style>
        </head>
        <body>
          <div class="emoji-grid">
            ${collage.map(row => row.map(emoji => `<e>${emoji}</e>`).join('')).join('\n')}
          </div>
        </body>
        </html>
      `;
      const newWindow = window.open('', '_blank');
      if (newWindow) { newWindow.document.open(); newWindow.document.write(htmlContent); newWindow.document.close(); }
      else { alert('Pop-up blocked. Please allow pop-ups for this website.'); }
    };

    const increaseZoom = () => setZoomLevel(prev => Math.min(prev + 0.1, 3));
    const decreaseZoom = () => setZoomLevel(prev => Math.max(prev - 0.1, 0.5));
    const resetZoom = () => setZoomLevel(1);

    let collagePreview = null;
    if (collage.length > 0) {
      const baseFontSize = Math.max(8, Math.min(32, 800 / resolution.width));
      const effectiveFontSize = baseFontSize * zoomLevel;
      const collageWidth = resolution.width * effectiveFontSize;
      const collageHeight = resolution.height * effectiveFontSize;
      collagePreview = h('div', {
        className: 'collage-container',
        style: { width: collageWidth + 'px', height: collageHeight + 'px', backgroundColor: bgColor }
      }, [
        h('div', {
          className: 'emoji-grid',
          style: { gridTemplateColumns: `repeat(${resolution.width}, 1em)`, fontSize: effectiveFontSize + 'px' }
        }, collage.flat().map((emoji, i) => h('e', { key: i }, emoji)))
      ]);
    }

    let palettePreview = null;
    if (paletteProgress < 100) {
      const keys = Object.keys(processedPalette);
      const sample = keys.length <= 50 ? keys : keys.slice(-50);
      palettePreview = h('div', { className: 'mt-4' }, [
        h('h2', { className: 'text-md font-medium mb-2' }, 'Palette Processing Preview:'),
        h('div', { className: 'grid grid-cols-10 gap-1' },
          sample.map(emoji => {
            const color = processedPalette[emoji];
            return h('div', {
              key: emoji,
              style: {
                backgroundColor: color ? `rgb(${color[0]}, ${color[1]}, ${color[2]})` : '#fff',
                border: '1px solid #ccc',
                width: '2em',
                height: '2em',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }
            }, emoji);
          })
        )
      ]);
    }

    const lowerSection = h('div', { style: { backgroundColor: bgColor, width: '100%' } }, [
      h('div', { className: 'p-6 max-w-6xl mx-auto' }, [
        h('div', { className: 'bg-white p-4 rounded shadow mt-4 flex flex-col gap-4' }, [
          originalImage && h('button', {
            onClick: generateCollage,
            className: 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50',
            disabled: processing || paletteProgress < 100
          }, paletteProgress < 100 ? 'Building Emoji Palette...' : (processing ? 'Generating...' : 'Generate Collage')),
          collage.length > 0 && h('div', { className: 'controls-row' }, [
            h('button', { onClick: downloadPNG, className: 'px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600' }, 'Download as PNG'),
            h('button', { onClick: downloadSVG, className: 'px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600' }, 'Download as SVG'),
            h('button', { onClick: openFullPage, className: 'px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600' }, 'Open as Full Page'),
            h('button', { onClick: decreaseZoom, className: 'zoom-button', title: 'Zoom Out' }, '-'),
            h('button', { onClick: resetZoom, className: 'zoom-button', title: 'Reset' }, 'Reset'),
            h('button', { onClick: increaseZoom, className: 'zoom-button', title: 'Zoom In' }, '+')
          ])
        ]),
        collagePreview,
        h('div', { className: 'mt-6 text-center text-sm text-gray-500' }, 'Â© 2025 Emoji Collage Maker')
      ])
    ]);

    return h('div', { className: 'p-6 max-w-6xl mx-auto' }, [
      h('h1', { className: 'text-4xl font-bold mb-6 text-center' }, 'Emoji Collage Maker'),
      h('div', { className: 'bg-white p-4 rounded shadow' }, [
        h('div', { className: 'flex flex-wrap gap-4' }, [
          h('div', { className: 'flex-1 min-w-[250px]' }, [
            h('div', { className: 'space-y-2 mb-4' }, [
              h('label', { className: 'block text-sm font-medium' }, 'Upload Image:'),
              h('input', {
                type: 'file',
                accept: 'image/*',
                onChange: handleImageUpload,
                className: 'block w-full text-sm text-gray-500'
              })
            ]),
            originalImage && h('div', { className: 'space-y-2 mb-4' }, [
              h('label', { className: 'block text-sm font-medium' }, 'Resolution:'),
              h('div', { className: 'flex gap-2 items-center' }, [
                h('input', {
                  type: 'number',
                  value: resolution.width,
                  onChange: (e) => updateResolution(+e.target.value, resolution.height, true),
                  className: 'w-20 px-2 py-1 border rounded'
                }),
                h('span', null, 'Ã—'),
                h('input', {
                  type: 'number',
                  value: resolution.height,
                  onChange: (e) => updateResolution(resolution.width, +e.target.value, false),
                  className: 'w-20 px-2 py-1 border rounded'
                })
              ])
            ]),
            originalImage && h('div', { className: 'space-y-2 mb-4' }, [
              h('label', { className: 'block text-sm font-medium' }, 'Background Color:'),
              h('input', {
                type: 'color',
                value: bgColor,
                onChange: (e) => setBgColor(e.target.value),
                className: 'w-12 h-12 p-0 border rounded'
              })
            ]),
            h('canvas', { ref: canvasRef, id: 'processingCanvas' }),
            h('div', { className: 'text-sm text-gray-600 mb-4' },
              paletteProgress < 100 
                ? `Building emoji palette: ${paletteProgress}% complete (cached for future collage generations)...`
                : 'Emoji palette ready!'
            ),
            palettePreview
          ]),
          originalImage && h('div', { className: 'flex-shrink-0' }, [
            h('h2', { className: 'text-lg font-medium mb-2' }, 'Original Image:'),
            h('img', {
              src: originalImage.src,
              className: 'border rounded',
              style: { maxHeight: '500px', maxWidth: '100%' }
            })
          ])
        ])
      ]),
      lowerSection
    ]);
  };

  render(h(App), document.getElementById('app'));
</script>

</body>
</html>
