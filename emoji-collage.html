<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emoji Collage Maker</title>
  <!-- Preact and Hooks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/preact/10.19.3/preact.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/preact/10.19.3/hooks.umd.js"></script>
  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    /* Emoji Grid Styling */
    .emoji-grid {
      display: grid;
      font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji";
      letter-spacing: 0;
      word-spacing: 0;
      gap: 1px; /* Reduced gap between emojis */
      transform-origin: top left;
    }
    /* Custom element <e> used for each emoji cell */
    e {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      width: 1em;
      height: 1em;
      padding: 0;
    }
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #ccc;
      transition: background-color 0.3s;
      margin-left: 8px;
    }
    /* Collage Container: its size is computed to exactly fit the emoji collage */
    .collage-container {
      overflow: visible;
      position: relative;
      border: 1px solid #ddd;
      margin-top: 1rem;
    }
    /* Controls Row (Download/Open + Zoom) */
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .zoom-button {
      padding: 4px 8px;
      background-color: #e2e8f0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .zoom-button:hover {
      background-color: #cbd5e1;
    }
    /* Processing Canvas */
    #processingCanvas {
      display: block;
      margin-top: 1rem;
      border: 1px solid #ccc;
      max-width: 100%;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="app"></div>
  <script>
    const { h, render } = window.preact;
    const { useState, useEffect, useRef } = window.preactHooks;

    /* Helper: Convert hex color to RGB array */
    const hexToRgb = (hex) => {
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const num = parseInt(hex, 16);
      return [(num >> 16) & 255, (num >> 8) & 255, num & 255];
    };

    /* Optimized Emoji Palette Generation:
       Only add skin tone variations for modifier-capable emojis.
       Also filter out the unwanted ðŸ”³ emoji.
    */
    const BASE_EMOJI_PALETTE = (() => {
      const ranges = [
        [0x1F300, 0x1F5FF],  // Miscellaneous Symbols and Pictographs
        [0x1F600, 0x1F64F],  // Emoticons
        [0x1F680, 0x1F6FF],  // Transport and Map Symbols
        [0x2600, 0x26FF],    // Miscellaneous Symbols
        [0x2700, 0x27BF],    // Dingbats
        [0x1F900, 0x1F9FF],  // Supplemental Symbols and Pictographs
        [0x1FA70, 0x1FAFF],  // Symbols and Pictographs Extended-A
      ];
      const skinTones = [
        '\u{1F3FB}', // Light Skin Tone
        '\u{1F3FC}', // Medium-Light Skin Tone
        '\u{1F3FD}', // Medium Skin Tone
        '\u{1F3FE}', // Medium-Dark Skin Tone
        '\u{1F3FF}', // Dark Skin Tone
      ];
      const emoji = new Set();
      for (const [start, end] of ranges) {
        for (let codePoint = start; codePoint <= end; codePoint++) {
          const baseChar = String.fromCodePoint(codePoint);
          // Filter out the unwanted icon ðŸ”³
          if (baseChar === "ðŸ”³") continue;
          if (/^\p{Emoji}$/u.test(baseChar)) {
            if (/\p{Emoji_Modifier_Base}/u.test(baseChar)) {
              emoji.add(baseChar);
              for (const tone of skinTones) {
                emoji.add(baseChar + tone);
              }
            } else {
              emoji.add(baseChar);
            }
          }
        }
      }
      return Array.from(emoji);
    })();

    /* Function to get cached emoji colors or process and cache them.
       Accepts two callbacks:
         - updateProgress: receives a value (0â€“100)
         - updatePartial: called with the current partial palette (object mapping emoji => [r, g, b])
       Here we update every 10 emojis.
    */
    const getCachedEmojiColors = async (updateProgress, updatePartial) => {
      const cached = localStorage.getItem('emojiColors');
      if (cached) {
        updateProgress(100);
        return JSON.parse(cached);
      } else {
        const colors = {};
        let partial = {};
        for (const [index, emoji] of BASE_EMOJI_PALETTE.entries()) {
          const result = await extractEmojiColor(emoji);
          colors[emoji] = result;
          partial[emoji] = result;
          if (updatePartial && index % 10 === 0) {
            updatePartial({ ...partial });
          }
          updateProgress(Math.floor(((index + 1) / BASE_EMOJI_PALETTE.length) * 100));
        }
        if (updatePartial) updatePartial(partial);
        localStorage.setItem('emojiColors', JSON.stringify(colors));
        return colors;
      }
    };

    /* Function to extract the dominant color of an emoji */
    const extractEmojiColor = (emoji) => {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        canvas.width = 50;
        canvas.height = 50;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = '40px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(emoji, canvas.width / 2, canvas.height / 2);
        setTimeout(() => {
          try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < data.length; i += 4) {
              if (data[i + 3] > 250 && !(data[i] > 250 && data[i + 1] > 250 && data[i + 2] > 250)) {
                r += data[i];
                g += data[i + 1];
                b += data[i + 2];
                count++;
              }
            }
            if (count > 0) {
              resolve([Math.round(r / count), Math.round(g / count), Math.round(b / count)]);
            } else {
              resolve([128, 128, 128]);
            }
          } catch (error) {
            console.error('Error analyzing emoji:', error);
            resolve([128, 128, 128]);
          }
        }, 10);
      });
    };

    const App = () => {
      const [imageData, setImageData] = useState(null);
      const [resolution, setResolution] = useState({ width: 32, height: 32 });
      const [emojiColors, setEmojiColors] = useState({});
      const [processedPalette, setProcessedPalette] = useState({});
      const [collage, setCollage] = useState([]);
      const [originalImage, setOriginalImage] = useState(null);
      const [readyToRender, setReadyToRender] = useState(false);
      const [paletteProgress, setPaletteProgress] = useState(0);
      const canvasRef = useRef(null);
      const [processing, setProcessing] = useState(false);
      const [zoomLevel, setZoomLevel] = useState(1);
      const [bgColor, setBgColor] = useState('#ffffff');

      useEffect(() => {
        const fetchEmojiColors = async () => {
          const colors = await getCachedEmojiColors(setPaletteProgress, setProcessedPalette);
          setEmojiColors(colors);
          setReadyToRender(true);
        };
        fetchEmojiColors();
      }, []);

      const calculateResolution = (width, height) => {
        const minDimension = 32;
        const aspectRatio = width / height;
        if (width < height) {
          return {
            width: minDimension,
            height: Math.round(minDimension / aspectRatio)
          };
        } else {
          return {
            width: Math.round(minDimension * aspectRatio),
            height: minDimension
          };
        }
      };

      const updateResolution = (newWidth, newHeight, isWidthUpdate) => {
        if (!originalImage || !canvasRef.current) return;
        const aspectRatio = originalImage.width / originalImage.height;
        let updatedWidth, updatedHeight;
        if (isWidthUpdate) {
          updatedWidth = newWidth;
          updatedHeight = Math.round(newWidth / aspectRatio);
        } else {
          updatedHeight = newHeight;
          updatedWidth = Math.round(newHeight * aspectRatio);
        }
        setResolution({ width: updatedWidth, height: updatedHeight });
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = updatedWidth;
        canvas.height = updatedHeight;
        ctx.drawImage(originalImage, 0, 0, updatedWidth, updatedHeight);
        setImageData(ctx.getImageData(0, 0, updatedWidth, updatedHeight));
        setCollage([]);
        setReadyToRender(true);
      };

      const handleImageUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            setOriginalImage(img);
            const newResolution = calculateResolution(img.width, img.height);
            setResolution(newResolution);
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = newResolution.width;
            canvas.height = newResolution.height;
            ctx.drawImage(img, 0, 0, newResolution.width, newResolution.height);
            setImageData(ctx.getImageData(0, 0, newResolution.width, newResolution.height));
            setCollage([]);
            setReadyToRender(true);
          };
          img.onerror = (error) => {
            console.error('Image failed to load:', error);
          };
          img.src = event.target.result;
        };
        reader.onerror = (error) => {
          console.error('File reading failed:', error);
        };
        reader.readAsDataURL(file);
      };

      /* Generate Collage:
         - Waits until the palette is ready.
         - For each pixel, blends the raw emoji color with the background color (80/20 blend).
         - Instead of always using the single best match, gathers candidates within 5% of the best diff and randomly selects one.
      */
      const generateCollage = () => {
        if (!imageData) {
          console.warn('No image data available to generate collage.');
          return;
        }
        if (paletteProgress < 100) {
          console.warn('Emoji palette is not ready yet.');
          return;
        }
        setProcessing(true);
        const data = imageData.data;
        const newCollage = [];
        const bgRgb = hexToRgb(bgColor);
        const blendFactor = 0.8; // 80% raw emoji color, 20% background
        for (let y = 0; y < resolution.height; y++) {
          const row = [];
          for (let x = 0; x < resolution.width; x++) {
            const i = (y * resolution.width + x) * 4;
            const pixelColor = [data[i], data[i + 1], data[i + 2]];
            let bestDiff = Infinity;
            let candidates = [];
            for (const emoji of BASE_EMOJI_PALETTE) {
              const rawColor = emojiColors[emoji];
              if (!rawColor) continue;
              const effectiveColor = [
                Math.round(rawColor[0] * blendFactor + bgRgb[0] * (1 - blendFactor)),
                Math.round(rawColor[1] * blendFactor + bgRgb[1] * (1 - blendFactor)),
                Math.round(rawColor[2] * blendFactor + bgRgb[2] * (1 - blendFactor))
              ];
              const diff = Math.sqrt(
                Math.pow(effectiveColor[0] - pixelColor[0], 2) +
                Math.pow(effectiveColor[1] - pixelColor[1], 2) +
                Math.pow(effectiveColor[2] - pixelColor[2], 2)
              );
              if (diff < bestDiff) {
                bestDiff = diff;
                candidates = [emoji];
              } else if (diff <= bestDiff * 1.05) {
                candidates.push(emoji);
              }
            }
            const bestEmoji = candidates[Math.floor(Math.random() * candidates.length)] || BASE_EMOJI_PALETTE[0];
            row.push(bestEmoji);
          }
          newCollage.push(row);
        }
        setCollage(newCollage);
        setProcessing(false);
      };

      /* Download as high-definition PNG with the chosen background color */
      const downloadPNG = () => {
        if (collage.length === 0) return;
        const tempCanvas = document.createElement('canvas');
        const scale = 20;
        tempCanvas.width = resolution.width * scale;
        tempCanvas.height = resolution.height * scale;
        const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        ctx.font = `${scale}px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji"`;
        ctx.textBaseline = 'top';
        for (let y = 0; y < resolution.height; y++) {
          for (let x = 0; x < resolution.width; x++) {
            const emoji = collage[y][x];
            ctx.fillText(emoji, x * scale, y * scale);
          }
        }
        tempCanvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'emoji_collage.png';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 'image/png');
      };

      /* Download as SVG with the chosen background color */
      const downloadSVG = () => {
        if (collage.length === 0) return;
        const emojiSize = 20;
        const svgWidth = resolution.width * emojiSize;
        const svgHeight = resolution.height * emojiSize;
        let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}">`;
        svgContent += `<rect width="100%" height="100%" fill="${bgColor}"/>`;
        for (let y = 0; y < resolution.height; y++) {
          for (let x = 0; x < resolution.width; x++) {
            const emoji = collage[y][x];
            svgContent += `<text x="${x * emojiSize}" y="${(y + 1) * emojiSize}" font-size="${emojiSize}" font-family="Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, Android Emoji">${emoji}</text>`;
          }
        }
        svgContent += '</svg>';
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'emoji_collage.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      /* Open collage as a full-page document with corrected emoji spacing using <e> */
      const openFullPage = () => {
        if (collage.length === 0) return;
        const baseFontSize = Math.max(8, Math.min(32, 800 / resolution.width));
        const effectiveFontSize = baseFontSize * zoomLevel;
        const htmlContent = `
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Emoji Collage</title>
            <style>
              body {
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: ${bgColor};
              }
              .emoji-grid {
                display: grid;
                grid-template-columns: repeat(${resolution.width}, 1em);
                gap: 1px;
                font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Android Emoji';
                letter-spacing: 0;
                word-spacing: 0;
                font-size: ${effectiveFontSize}px;
              }
              e {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                line-height: 1;
                width: 1em;
                height: 1em;
                padding: 0;
              }
            </style>
          </head>
          <body>
            <div class="emoji-grid">
              ${collage.map(row => row.map(emoji => `<e>${emoji}</e>`).join('')).join('\n')}
            </div>
          </body>
          </html>
        `;
        const newWindow = window.open('', '_blank');
        if (newWindow) {
          newWindow.document.open();
          newWindow.document.write(htmlContent);
          newWindow.document.close();
        } else {
          alert('Failed to open a new window. Please allow pop-ups for this website.');
        }
      };

      /* Zoom Controls */
      const increaseZoom = () => setZoomLevel(prev => Math.min(prev + 0.1, 3));
      const decreaseZoom = () => setZoomLevel(prev => Math.max(prev - 0.1, 0.5));
      const resetZoom = () => setZoomLevel(1);

      /* Compute the effective font size and container dimensions for the collage preview */
      let collagePreview = null;
      if (collage.length > 0) {
        const baseFontSize = Math.max(8, Math.min(32, 800 / resolution.width));
        const effectiveFontSize = baseFontSize * zoomLevel;
        const collageWidth = resolution.width * effectiveFontSize;
        const collageHeight = resolution.height * effectiveFontSize;
        collagePreview = h('div', {
          className: 'collage-container',
          style: {
            width: collageWidth + 'px',
            height: collageHeight + 'px',
            backgroundColor: bgColor
          }
        }, [
          h('div', {
            className: 'emoji-grid',
            style: {
              gridTemplateColumns: `repeat(${resolution.width}, 1em)`,
              fontSize: effectiveFontSize + 'px'
            }
          },
            collage.flat().map((emoji, i) =>
              h('e', { key: i }, emoji)
            )
          )
        ]);
      }

      /* Palette Processing Preview:
         When the palette is still being built, show a preview of up to 50 emojis sampled from the *last* processed.
      */
      let palettePreview = null;
      if (paletteProgress < 100) {
        const keys = Object.keys(processedPalette);
        const sample = keys.length <= 50 ? keys : keys.slice(-50);
        palettePreview = h('div', { className: 'mt-4' }, [
          h('h2', { className: 'text-md font-medium mb-2' }, 'Palette Processing Preview:'),
          h('div', { className: 'grid grid-cols-10 gap-1' },
            sample.map(emoji => {
              const color = processedPalette[emoji];
              return h('div', {
                key: emoji,
                style: {
                  backgroundColor: color ? `rgb(${color[0]}, ${color[1]}, ${color[2]})` : '#fff',
                  border: '1px solid #ccc',
                  width: '2em',
                  height: '2em',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center'
                }
              }, emoji);
            })
          )
        ]);
      }

      /* Wrap the lower section (collage actions, preview, processing canvas, and footer)
         in a full-width container whose background color is the chosen bgColor.
      */
      const lowerSection = h('div', { style: { backgroundColor: bgColor, width: '100%' } }, [
        h('div', { className: 'p-6 max-w-6xl mx-auto' }, [
          h('div', { className: 'bg-white p-4 rounded shadow mt-4 flex flex-col gap-4' }, [
            originalImage && h('button', {
              onClick: generateCollage,
              className: 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50',
              disabled: processing || paletteProgress < 100
            }, paletteProgress < 100
                ? 'Building Emoji Palette...'
                : processing ? 'Generating...' : 'Generate Collage'
            ),
            collage.length > 0 && h('div', { className: 'controls-row' }, [
              h('button', {
                onClick: downloadPNG,
                className: 'px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600'
              }, 'Download as PNG'),
              h('button', {
                onClick: downloadSVG,
                className: 'px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600'
              }, 'Download as SVG'),
              h('button', {
                onClick: openFullPage,
                className: 'px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600'
              }, 'Open as Full Page'),
              h('button', {
                onClick: decreaseZoom,
                className: 'zoom-button',
                title: 'Zoom Out'
              }, '-'),
              h('button', {
                onClick: resetZoom,
                className: 'zoom-button',
                title: 'Reset'
              }, 'Reset'),
              h('button', {
                onClick: increaseZoom,
                className: 'zoom-button',
                title: 'Zoom In'
              }, '+')
            ]),
            collagePreview
          ]),
          h('canvas', { ref: canvasRef, id: 'processingCanvas' }),
          h('div', { className: 'mt-6 text-center text-sm text-gray-500' }, 'Â© 2025 Emoji Collage Maker')
        ])
      ]);

      return h('div', { className: 'p-6 max-w-6xl mx-auto' }, [
        h('h1', { className: 'text-4xl font-bold mb-6 text-center' }, 'Emoji Collage Maker'),
        h('div', { className: 'bg-white p-4 rounded shadow' }, [
          h('div', { className: 'flex flex-wrap gap-4' }, [
            h('div', { className: 'flex-1 min-w-[250px]' }, [
              h('div', { className: 'space-y-2 mb-4' }, [
                h('label', { className: 'block text-sm font-medium' }, 'Upload Image:'),
                h('input', {
                  type: 'file',
                  accept: 'image/*',
                  onChange: handleImageUpload,
                  className: 'block w-full text-sm text-gray-500'
                })
              ]),
              originalImage && h('div', { className: 'space-y-2 mb-4' }, [
                h('label', { className: 'block text-sm font-medium' }, 'Resolution:'),
                h('div', { className: 'flex gap-2 items-center' }, [
                  h('input', {
                    type: 'number',
                    value: resolution.width,
                    onChange: (e) => updateResolution(+e.target.value, resolution.height, true),
                    className: 'w-20 px-2 py-1 border rounded'
                  }),
                  h('span', null, 'Ã—'),
                  h('input', {
                    type: 'number',
                    value: resolution.height,
                    onChange: (e) => updateResolution(resolution.width, +e.target.value, false),
                    className: 'w-20 px-2 py-1 border rounded'
                  })
                ])
              ]),
              originalImage && h('div', { className: 'space-y-2 mb-4' }, [
                h('label', { className: 'block text-sm font-medium' }, 'Background Color:'),
                h('input', {
                  type: 'color',
                  value: bgColor,
                  onChange: (e) => setBgColor(e.target.value),
                  className: 'w-12 h-12 p-0 border rounded'
                })
              ]),
              h('div', { className: 'text-sm text-gray-600 mb-4' }, 
                paletteProgress < 100
                  ? `Building emoji palette: ${paletteProgress}% complete (cached for future collage generations)...`
                  : 'Emoji palette ready!'
              ),
              palettePreview
            ]),
            originalImage && h('div', { className: 'flex-shrink-0' }, [
              h('h2', { className: 'text-lg font-medium mb-2' }, 'Original Image:'),
              h('img', {
                src: originalImage.src,
                className: 'border rounded',
                style: { maxHeight: '500px', maxWidth: '100%' }
              })
            ])
          ])
        ]),
        lowerSection
      ]);
    };

    render(h(App), document.getElementById('app'));
  </script>
</body>
</html>
